<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.boychai.xyz","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"base16/google-dark","dark":"base16/google-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="写在前面 没想到我有一天会去研究汇编，这是我从未设想的道路。😭  学习环境安装 项目地址： https:&#x2F;&#x2F;github.com&#x2F;HaiPenglai&#x2F;bilibili_assembly&#x2F; 教学视频： https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1eG4y1S7R5 安装配置具体可以参考视频，非常详细，本文不多介绍环境的安装与配置。  基础指令与寄存器 Debug命令 概述">
<meta property="og:type" content="article">
<meta property="og:title" content="8086CPU汇编学习">
<meta property="og:url" content="https://blog.boychai.xyz/2025/03/10/8086CPU%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="BoyChai&#39;s Blog">
<meta property="og:description" content="写在前面 没想到我有一天会去研究汇编，这是我从未设想的道路。😭  学习环境安装 项目地址： https:&#x2F;&#x2F;github.com&#x2F;HaiPenglai&#x2F;bilibili_assembly&#x2F; 教学视频： https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1eG4y1S7R5 安装配置具体可以参考视频，非常详细，本文不多介绍环境的安装与配置。  基础指令与寄存器 Debug命令 概述">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308200824.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308201648.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308203125.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308204550.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308211341.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308212718.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309114424.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309115246.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309115715.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309120520.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309121405.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309121909.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309122149.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309122321.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309123232.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309123522.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309130428.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309131638.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309132351.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309140106.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309142035.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309142243.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309183659.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310085436.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310085535.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310085639.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310093528.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310095922.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310100052.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310100419.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310100546.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310101904.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310102246.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310102728.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310103523.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310112303.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310112811.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310113246.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310113424.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310113748.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310114159.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310141934.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310142305.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310142447.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310142632.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310142844.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310154216.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310154440.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310154637.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310154752.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310155515.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310155832.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310162649.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310165002.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310170031.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313193258.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313193535.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313195107.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313195227.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313195351.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313201854.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313203043.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313203249.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313203428.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313204425.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313205706.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314152530.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314152551.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314152739.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314163915.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314164049.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314164259.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314164429.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314164821.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314165006.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314165421.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314205856.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314210009.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314210157.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314210314.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314204059.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315132312.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315134654.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315135359.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315150452.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315151141.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315191910.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315191929.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201358.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201416.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201445.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201507.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201639.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201758.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315203531.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315211019.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315211949.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315212153.png">
<meta property="og:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315213751.png">
<meta property="article:published_time" content="2025-03-10T16:01:00.000Z">
<meta property="article:modified_time" content="2025-07-17T05:40:18.597Z">
<meta property="article:author" content="BoyChai">
<meta property="article:tag" content="asm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308200824.png">


<link rel="canonical" href="https://blog.boychai.xyz/2025/03/10/8086CPU%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.boychai.xyz/2025/03/10/8086CPU%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/","path":"2025/03/10/8086CPU汇编学习/","title":"8086CPU汇编学习"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>8086CPU汇编学习 | BoyChai's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="dns-prefetch" href="waline-server-ten-phi.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="BoyChai's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband">
  <a target="_blank" rel="noopener" href="https://github.com/boychai" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  </div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">BoyChai's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-开往"><a href="https://www.travellings.cn/go.html" rel="section" target="_blank"><i class="fa fa-car fa-fw"></i>开往</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="nav-number">2.</span> <span class="nav-text">学习环境安装</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">基础指令与寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Debug%E5%91%BD%E4%BB%A4"><span class="nav-number">3.1.</span> <span class="nav-text">Debug命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-number">3.1.2.</span> <span class="nav-text">功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%B1%82%E7%BA%A7"><span class="nav-number">3.2.</span> <span class="nav-text">寄存器层级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MOV%E6%8C%87%E4%BB%A4"><span class="nav-number">3.3.</span> <span class="nav-text">MOV指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADD%E6%8C%87%E4%BB%A4"><span class="nav-number">3.4.</span> <span class="nav-text">ADD指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SUB%E6%8C%87%E4%BB%A4"><span class="nav-number">3.5.</span> <span class="nav-text">SUB指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MUL%E6%8C%87%E4%BB%A4"><span class="nav-number">3.6.</span> <span class="nav-text">MUL指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DIV%E6%8C%87%E4%BB%A4"><span class="nav-number">3.7.</span> <span class="nav-text">DIV指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AND%E6%8C%87%E4%BB%A4"><span class="nav-number">3.8.</span> <span class="nav-text">AND指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OR%E6%8C%87%E4%BB%A4"><span class="nav-number">3.9.</span> <span class="nav-text">OR指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SHL%E5%92%8CSHR%E6%8C%87%E4%BB%A4"><span class="nav-number">3.10.</span> <span class="nav-text">SHL和SHR指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ROL%E5%92%8CROR%E6%8C%87%E4%BB%A4"><span class="nav-number">3.11.</span> <span class="nav-text">ROL和ROR指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#INC%E5%92%8CDEC%E6%8C%87%E4%BB%A4"><span class="nav-number">3.12.</span> <span class="nav-text">INC和DEC指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NOP%E6%8C%87%E4%BB%A4"><span class="nav-number">3.13.</span> <span class="nav-text">NOP指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XCHG%E6%8C%87%E4%BB%A4"><span class="nav-number">3.14.</span> <span class="nav-text">XCHG指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NEG%E6%8C%87%E4%BB%A4"><span class="nav-number">3.15.</span> <span class="nav-text">NEG指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#INT%E6%8C%87%E4%BB%A4"><span class="nav-number">3.16.</span> <span class="nav-text">INT指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">进阶指令与寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E3%80%81%E6%AE%B5%E5%9C%B0%E5%9D%80%E3%80%81%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%85%B3%E7%B3%BB"><span class="nav-number">4.1.</span> <span class="nav-text">物理地址、段地址、偏移地址关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">4.2.</span> <span class="nav-text">段寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">4.3.</span> <span class="nav-text">关于内存写入数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DS%E5%AF%84%E5%AD%98%E5%99%A8-%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%9C%B0%E5%9D%80"><span class="nav-number">4.4.</span> <span class="nav-text">DS寄存器-数据段地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CS%E5%92%8CIP%E6%8C%87%E4%BB%A4"><span class="nav-number">4.5.</span> <span class="nav-text">CS和IP指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMP%E6%8C%87%E4%BB%A4"><span class="nav-number">4.6.</span> <span class="nav-text">JMP指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E6%A6%82%E5%BF%B5"><span class="nav-number">4.7.</span> <span class="nav-text">栈概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SS%E5%92%8CSP%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">4.8.</span> <span class="nav-text">SS和SP寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PUSH%E5%92%8CPOP%E6%8C%87%E4%BB%A4"><span class="nav-number">4.9.</span> <span class="nav-text">PUSH和POP指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BX%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E7%8B%AC%E7%89%B9%E6%80%A7"><span class="nav-number">4.10.</span> <span class="nav-text">BX寄存器的独特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SI%E5%92%8CDI%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">4.11.</span> <span class="nav-text">SI和DI寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BP%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">4.12.</span> <span class="nav-text">BP寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93"><span class="nav-number">4.13.</span> <span class="nav-text">寻址寄存器相关总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%BF%97%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">4.14.</span> <span class="nav-text">标志位寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ZF%E6%A0%87%E5%BF%97"><span class="nav-number">4.14.1.</span> <span class="nav-text">ZF标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PF%E6%A0%87%E5%BF%97"><span class="nav-number">4.14.2.</span> <span class="nav-text">PF标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SF%E6%A0%87%E5%BF%97"><span class="nav-number">4.14.3.</span> <span class="nav-text">SF标志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9F%E6%95%B0%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%EF%BC%9F"><span class="nav-number">4.14.3.1.</span> <span class="nav-text">负数如何表示？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C"><span class="nav-number">4.14.3.2.</span> <span class="nav-text">实验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CF%E6%A0%87%E5%BF%97"><span class="nav-number">4.14.4.</span> <span class="nav-text">CF标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OF%E6%A0%87%E5%BF%97"><span class="nav-number">4.14.5.</span> <span class="nav-text">OF标志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADC%E6%8C%87%E4%BB%A4"><span class="nav-number">4.15.</span> <span class="nav-text">ADC指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SBB%E6%8C%87%E4%BB%A4"><span class="nav-number">4.16.</span> <span class="nav-text">SBB指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMP%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">4.17.</span> <span class="nav-text">CMP指令与跳转指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81"><span class="nav-number">5.</span> <span class="nav-text">源文件编写代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8CASM%E6%BA%90%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6"><span class="nav-number">5.1.</span> <span class="nav-text">运行ASM源代码文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LOOP%E6%8C%87%E4%BB%A4"><span class="nav-number">5.2.</span> <span class="nav-text">LOOP指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Debug%E6%8C%87%E4%BB%A4G"><span class="nav-number">5.3.</span> <span class="nav-text">Debug指令G</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Debug%E6%8C%87%E4%BB%A4P"><span class="nav-number">5.4.</span> <span class="nav-text">Debug指令P</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CALL%E4%B8%8ERET%E6%8C%87%E4%BB%A4"><span class="nav-number">5.5.</span> <span class="nav-text">CALL与RET指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RET%E5%92%8CRETF"><span class="nav-number">5.5.1.</span> <span class="nav-text">RET和RETF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#call%E5%92%8C%E2%80%9Ccall-far-ptr%E2%80%9D"><span class="nav-number">5.5.2.</span> <span class="nav-text">call和“call far ptr”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CALL%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">5.5.3.</span> <span class="nav-text">CALL指令的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RET%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">5.5.4.</span> <span class="nav-text">RET指令的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.5.5.</span> <span class="nav-text">案例实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%A3%85%E8%BD%BD%E6%95%B0%E6%8D%AE"><span class="nav-number">5.6.</span> <span class="nav-text">代码中装载数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E3%80%81%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5"><span class="nav-number">5.7.</span> <span class="nav-text">将数据、代码、栈放入不同的段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OFFSET%E6%8C%87%E4%BB%A4"><span class="nav-number">5.8.</span> <span class="nav-text">OFFSET指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMP%E6%8C%87%E4%BB%A4%E8%BF%9B%E9%98%B6"><span class="nav-number">5.9.</span> <span class="nav-text">JMP指令进阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JCXZ%E6%8C%87%E4%BB%A4"><span class="nav-number">5.10.</span> <span class="nav-text">JCXZ指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TYPE%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-number">5.11.</span> <span class="nav-text">TYPE伪指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5"><span class="nav-number">5.12.</span> <span class="nav-text">数组的读取和写入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%90%8E%E9%9D%A2"><span class="nav-number">6.</span> <span class="nav-text">写在后面</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="BoyChai"
      src="https://avatars.githubusercontent.com/u/88495409?s=96&v=4">
  <p class="site-author-name" itemprop="name">BoyChai</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">75</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/BoyChai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BoyChai" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:admin@boychai.xyz" title="E-Mail → mailto:admin@boychai.xyz" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/277637284" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;277637284" rel="noopener me" target="_blank"><i class="fab fa-bilibili fa-fw"></i>Bilibili</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.boychai.xyz/2025/03/10/8086CPU%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/88495409?s=96&v=4">
      <meta itemprop="name" content="BoyChai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoyChai's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="8086CPU汇编学习 | BoyChai's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          8086CPU汇编学习
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-10 16:01:00" itemprop="dateCreated datePublished" datetime="2025-03-10T16:01:00+00:00">2025-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">开发相关</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/asm/" itemprop="url" rel="index"><span itemprop="name">asm</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/03/10/8086CPU%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/03/10/8086CPU%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>43 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>没想到我有一天会去研究汇编，这是我从未设想的道路。😭</p>
<h1 id="学习环境安装"><a href="#学习环境安装" class="headerlink" title="学习环境安装"></a>学习环境安装</h1><p>项目地址： <a target="_blank" rel="noopener" href="https://github.com/HaiPenglai/bilibili_assembly/">https://github.com/HaiPenglai/bilibili_assembly/</a><br>教学视频： <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eG4y1S7R5">https://www.bilibili.com/video/BV1eG4y1S7R5</a><br>安装配置具体可以参考视频，非常详细，本文不多介绍环境的安装与配置。</p>
<h1 id="基础指令与寄存器"><a href="#基础指令与寄存器" class="headerlink" title="基础指令与寄存器"></a>基础指令与寄存器</h1><h2 id="Debug命令"><a href="#Debug命令" class="headerlink" title="Debug命令"></a>Debug命令</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Debug是DOS、Windows都提供的实模式(8086 方式)程序的调试工具。使用它，可以查看CPU各种寄存器中的内容，内存的情况和机器码级跟踪程序的运行。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>R命令 查看、改变CPU寄存器的内容。</li>
<li>D命令 查看内存中的内容。</li>
<li>E命令 改写内存中的内容。</li>
<li>U命令 将内存中的机器指令翻译成汇编指令。</li>
<li>T命令 执行一条机器命令。</li>
<li>A命令 以汇编指令的格式在内存中写入一条机器指令。</li>
</ul>
<h2 id="寄存器层级"><a href="#寄存器层级" class="headerlink" title="寄存器层级"></a>寄存器层级</h2><p>在 x86 架构的汇编语言中，寄存器的命名和使用方式有一定的规律。在Debug中，使用<code>R</code>指令可以看到寄存器中的内容<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308200824.png"><br>以AX为例，他的内容是<code>0000</code>，他拥有<code>16位</code>，在汇编指令中<code>AX</code>即直接代表这个<code>16位</code>寄存器，如果是<code>AH</code>和<code>AL</code>则代表<code>8位</code>寄存器，<code>H</code>是高位，<code>L</code>是低位，当前是X86的，如果是64的他还有<code>32位</code>，即<code>EAX</code>。</p>
<h2 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h2><p>MOV是做替换，在DEBUG中，执行下面汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,13</span><br><span class="line">mov bl,33</span><br><span class="line">mov ch,al</span><br></pre></td></tr></table></figure>
<p>执行过后ax寄存器的高位变成了13，bx的低位变成了33，cx的低位变没变，因为他把cx的高位修改成了ax的低位，ax的低位本身没内容即00。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308201648.png"></p>
<h2 id="ADD指令"><a href="#ADD指令" class="headerlink" title="ADD指令"></a>ADD指令</h2><p>ADD是做加法，在DEBUG中，执行下面汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add ax,13</span><br><span class="line">add bx,8</span><br><span class="line">add cx,bx</span><br></pre></td></tr></table></figure>
<p>AX从1300变成了1313，因为加了13，bx从0033变成了003B，他这里展示的是16进制，3+8&#x3D;11，11刚好对应B，然后CX本身就是0000，加上bx那就是003B<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308203125.png"></p>
<h2 id="SUB指令"><a href="#SUB指令" class="headerlink" title="SUB指令"></a>SUB指令</h2><p>SUB是做减法，在DEBUG中，执行下面汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub ax,8</span><br><span class="line">mov bx,F</span><br><span class="line">sub ax,bx</span><br></pre></td></tr></table></figure>
<p>第一条是1313-8，即130B(11)，之后bx改为F(15)，用ax即130B-F则AX&#x3D;12FC，相当于130B(11)-15 12F(15)C(12)<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308204550.png"></p>
<h2 id="MUL指令"><a href="#MUL指令" class="headerlink" title="MUL指令"></a>MUL指令</h2><p>mul是乘法指令，使用mul做乘法的时候需要注意下面两点</p>
<ul>
<li>相乘：两个相乘的数，要么都是8位，要么就都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中，如果是16位，一个默认在ax中，另一个放在16位reg或内存字单元中。</li>
<li>结果：如果是8位乘法，结果默认放在AX中，如果是16位乘法，结果高位默认在DX中存放，低位在AX中放。</li>
</ul>
<p>例如我要做100*10的运算，他应该是执行下面的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,64</span><br><span class="line">mov bl,A</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure>
<p>64是100的16进制，A是10的16进制，然后mul是运算，得到03E8，03E8刚好是1000的16进制。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308211341.png"><br>下面做一个100*10000的运算，他会不会出现溢出？100小于255，可是10000大于255，所以必须走16位的乘法，汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,64</span><br><span class="line">mov bx,2710</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure>
<p>这个正常的答案应该是1000000，16进制即F4240，在执行之后的结果中，因为位数不够他会把低位放到AX中，高位放到DX中，DX即F，AX就是4240，实际就是F4240即1000000。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250308212718.png"></p>
<h2 id="DIV指令"><a href="#DIV指令" class="headerlink" title="DIV指令"></a>DIV指令</h2><p>div是除法指令，使用div做除法的时候应该注意一下问题</p>
<ul>
<li>除数：有8位和16位两种，在一个reg或内存单元中。</li>
<li>被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果出书为16位，被出示则为32位，在DX和AX中存放，DX存放高位16位，AX存放低位16位。</li>
<li>结果：如果除数为8位，则AL存储触发操作的商，AH存储触发操作的余数；如果储是为16位，则AX存储除法操作的商，DX存储法操作的余数。</li>
</ul>
<p>下面做一个10000&#x2F;100的一个计算，10000的16进制是2710，100的16进制是64，那么计算的汇编代码将是这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2710</span><br><span class="line">mov bl,64</span><br><span class="line">div bl</span><br></pre></td></tr></table></figure>
<p>运行div之后他把答案最终放置到了ax中，64即16进制的100，10000&#x2F;100&#x3D;100<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309114424.png"><br>上面这种情况一个是被除数是16位，如果计算1000000&#x2F;10000，10000000的16进制数是F4240，很显然16位数是放不下的，那就需要把高位放到dx中，参考下面的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,F</span><br><span class="line">mov ax,4240</span><br><span class="line">mov bx,2710</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>
<p>成功运行那道ax中的运行结果64即10进制的100。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309115246.png"><br>如果运算结果中有余数呢？这里也可以做一下试验，1000001&#x2F;10000的结果应该是100余1，我们执行下面汇编代码来查看结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,F</span><br><span class="line">mov ax,4241</span><br><span class="line">mov bx,2710</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>
<p>这里发现余数会存储在dx寄存器中。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309115715.png"><br>上面的是一个32位占用的被除数，如果被除数是8位，则AL存储除法操作的商，AH放余数，可以参考10001&#x2F;100，汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2711</span><br><span class="line">mov bl,64</span><br><span class="line">div bl</span><br></pre></td></tr></table></figure>
<p>结果应该是100余1，对应的al的值则就是64，ah的值则就是1<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309120520.png"></p>
<h2 id="AND指令"><a href="#AND指令" class="headerlink" title="AND指令"></a>AND指令</h2><p>and指令的作用是按位进行与运算，举个例子<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309121405.png"><br>0和0则就是0，1和0还是0，1和1即1，参考汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,63(01100011B)</span><br><span class="line">and al,3B(00111011B)</span><br></pre></td></tr></table></figure>
<p>执行过后会把内容丢到al中，运行结果应该是00100011即16进制的23。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309121909.png"></p>
<h2 id="OR指令"><a href="#OR指令" class="headerlink" title="OR指令"></a>OR指令</h2><p>or指令的作用是按位进行或运算，举个例子<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309122149.png"><br>0和0就是0，1和1就是1，1和0就是1，0和1也是1，参考汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,63(01100011B)</span><br><span class="line">or al,7B(01111011B)</span><br></pre></td></tr></table></figure>
<p>二进制结果应该是01111011，16进制即7B。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309122321.png"></p>
<h2 id="SHL和SHR指令"><a href="#SHL和SHR指令" class="headerlink" title="SHL和SHR指令"></a>SHL和SHR指令</h2><p>shel和shr分别代表左移和右移，左移就是左边去除一个右边补0，右移则就是右边移除一个左边补零。如下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309123232.png"><br>参考汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,63</span><br><span class="line">shl al,1</span><br><span class="line">shr al,1</span><br></pre></td></tr></table></figure>
<p>63的二进制是01100011即16进制63，左移一位二进制变成11000110即16进制C6，右移一位则就变回去了即01100011即16进制的63。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309123522.png"></p>
<h2 id="ROL和ROR指令"><a href="#ROL和ROR指令" class="headerlink" title="ROL和ROR指令"></a>ROL和ROR指令</h2><p>他俩是循环左移和循环右移，他和普通的左移和右移区别是，循环左移是把最右边的一位补到最左边，循环右移是把最左边的一位补到右边，参考下面的汇编代码查看区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,FF</span><br><span class="line">rol al,1</span><br><span class="line">shl al,1</span><br></pre></td></tr></table></figure>
<p>FF的2进制是11111111，不管是循环左移还是右翼都是会把一边的1补到另一边，而shl和shr是补0。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309130428.png"></p>
<h2 id="INC和DEC指令"><a href="#INC和DEC指令" class="headerlink" title="INC和DEC指令"></a>INC和DEC指令</h2><p>INC和DEC的作用是增加1和减少1，例如C语言中的++和–，例子汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">inc al</span><br><span class="line">dec al</span><br></pre></td></tr></table></figure>
<p>这个不错介绍，需要注意的是，如果本身是al是00，再去给他dec(–)那么他就会变成FF，对应的如果是al是FF再去给他inc(++)那就会变成00。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309131638.png"></p>
<h2 id="NOP指令"><a href="#NOP指令" class="headerlink" title="NOP指令"></a>NOP指令</h2><p>这个指令是空代码段，执行不会干任何事情，他所占的空间恰好是1个字节。这里不多说，后面会用到。</p>
<h2 id="XCHG指令"><a href="#XCHG指令" class="headerlink" title="XCHG指令"></a>XCHG指令</h2><p>xchg指令的作用是做数据调换，参考下面汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,11</span><br><span class="line">mov bl,22</span><br><span class="line">xchg al,bl</span><br></pre></td></tr></table></figure>
<p>al和bl的内容互换了，如果是不通过这个指令来去作交换，则需要三个地方存储数据，A把数据给C，然后B把数据给A，再然后C给B这样才能呼唤，这个指令可以直接交换。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309132351.png"></p>
<h2 id="NEG指令"><a href="#NEG指令" class="headerlink" title="NEG指令"></a>NEG指令</h2><p>neg的作用是取反并加 1，如果原数据为<code>00000001</code>，通过neg取反+1就是<code>11111110</code>+<code>00000001</code>，具体汇编代码参考如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">neg al</span><br></pre></td></tr></table></figure>
<p>00000001取反就是11111110，再去加1那就是FF了，这里不多说。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309140106.png"></p>
<h2 id="INT指令"><a href="#INT指令" class="headerlink" title="INT指令"></a>INT指令</h2><p>INT指令的含义是中断，在做除法运算的时候如果除数为0那就会自动触发<code>int 0</code>这个指令，也可以手动执行这个指令，这个指令最终会把内存的执行指针做一个跳转，跳转到最初的位置，具体参考案例如下，第一个是除法除以0，汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,123</span><br><span class="line">mov bl,0</span><br><span class="line">div bl</span><br></pre></td></tr></table></figure>
<p>运行到div命令开始执行除法的时候，把CS和IP调到F000和1060，这个就是执行int 0会发生的事，出现问题则会跳转到这个位置。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309142035.png"><br>第二个例子直接运行<code>int 0</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 0</span><br></pre></td></tr></table></figure>
<p><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309142243.png"><br>这俩寄存器是用来存储执行代码位置的，他这里直接跳转了。<br>中断编号有很多，这里是调用的0，除法出现错误也会调用中断0，还有很多后面慢慢接触就可以了。</p>
<h1 id="进阶指令与寄存器"><a href="#进阶指令与寄存器" class="headerlink" title="进阶指令与寄存器"></a>进阶指令与寄存器</h1><h2 id="物理地址、段地址、偏移地址关系"><a href="#物理地址、段地址、偏移地址关系" class="headerlink" title="物理地址、段地址、偏移地址关系"></a>物理地址、段地址、偏移地址关系</h2><p>我这里说的都是基于8086CPU的内容，其他的可能和我这个不一样的。CPU在访问内存的时候，会用一个基础地址(段地址*16)和一个相对地址的偏移地址相加，给出内存单元的物理地址。<br>更一般的说，8086CPU的这种寻址功能是“基础地址+偏移地址&#x3D;物理地址”寻址模式的一种具体实现方案。8086CPU中，段地址x16可看作是基础地址。</p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>在8086CPU中，访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。这里，需要看一下，什么是部件提供段地址。段地址在8086CPU中段寄存器中存放。8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这四个段寄存器提供内存单元的段地址。</p>
<h2 id="关于内存写入数据"><a href="#关于内存写入数据" class="headerlink" title="关于内存写入数据"></a>关于内存写入数据</h2><p>通过Debug程序的e命令可以直接对内存中的数据做修改，可以参考下面截图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250309183659.png"></p>
<h2 id="DS寄存器-数据段地址"><a href="#DS寄存器-数据段地址" class="headerlink" title="DS寄存器-数据段地址"></a>DS寄存器-数据段地址</h2><p>CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段和地址。举个例子，通过下面debug命令在<code>21f6:0000</code>的位置写入一点内容，命令如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310085436.png"><br>再去修改DS寄存器的内容，DS寄存器的内容应该是数据段的地址，例如采用debug命令去直接修改DS(段寄存器是不可以直接mov数值修改，需要通过其他寄存器进行赋值)寄存器的内容，参考命令截图如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310085535.png"><br>通过mov去赋值DS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,21f6</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure>
<p>要注意直接去<code>mov ds,21f6</code>是不可行的，他是一个段寄存器在设计的时候就不允许这样。<br>去执行下面的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov al,[0]</span><br></pre></td></tr></table></figure>
<p>执行之后结果如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310085639.png"><br>al寄存器变成了12，这个12是哪里来的呢？在执行mov指令的时候，给的值是<code>[0]</code>这个值是指基于数据段地址的偏移，也就是基于DS,21F6这个位置的第0偏移的数据内容给al，即12。<br>在看一个案例，还是上面的内容，执行下面的汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov bx,[2]</span><br></pre></td></tr></table></figure>
<p>结果如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310093528.png"><br>为什么BX是7856？bx给的是216f的第2位，也就是从56开始，数值应该是<code>5678</code>，变成7856的原因是因为他要对其高低位，低位在bl，高位在bh，高位是78，低位是56，对其之后bx就是7856。</p>
<h2 id="CS和IP指令"><a href="#CS和IP指令" class="headerlink" title="CS和IP指令"></a>CS和IP指令</h2><p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器，从名称上我们可以看出它们和指令的关系。先看个案例，我们先在2000:0000的位置写入一些汇编指令，参考指令如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a 2000:0000</span><br><span class="line">mov ax,0123</span><br><span class="line">mov bx,0003</span><br><span class="line">mov ax,bx</span><br><span class="line">add ax,bx</span><br></pre></td></tr></table></figure>
<p><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310095922.png"><br>执行过后看一下对应位置的内容，发现里面的内容根本看不懂，这里的内容是刚才汇编指令的机器码，可以使用debug的u命令去看这些内容到底是执行的什么内容，参考下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310100052.png"><br>使用u命令可以看到咱们刚才输入的指令，具体怎么执行这些指令呢，这里就可以通过修改cs和ip寄存器来指定咱们写入命令的位置，再去使用t即可执行咱们这些指令，具体操作如下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310100419.png"><br>这个时候就相当于命令的指针指向了这里，通过t命令去执行命令结果如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310100546.png"><br>发现咱们再2000:0000设置的指令都依次执行了。</p>
<h2 id="JMP指令"><a href="#JMP指令" class="headerlink" title="JMP指令"></a>JMP指令</h2><p>jmp是一个跳转指令，具体的作用可以做一个实践，根据下图把命令写入内存。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310101904.png"><br>具体命令参考如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310102246.png"><br>我们把指针跳转到2000:0000开始执行命令，具体命令参考如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310102728.png"><br>当我们执行第二次的时候也就是命令<code>jmp 1000:3</code>的时候，cs和ip变成了1000和0003，下一个命令就会去执行<code>mov ax,0000</code>了，继续执行查看结果<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310103523.png"><br>继续执行会发现，他后面会有个jmp指令，jmp的参数是bx，bx是0000，就是把ip改为0000，那就是从<code>mov ax,0123</code>从头继续执行，然后一直重复，如果一直去执行那么这就是一个死循环。</p>
<h2 id="栈概念"><a href="#栈概念" class="headerlink" title="栈概念"></a>栈概念</h2><p>栈是一种后进先出的数据结构，通常用于存储临时数据、管理函数调用和返回地址。栈在内存中通常从高地址向低地址增长，用于保存寄存器值、局部变量等。简单说，就是程序运行时的“临时记事本”。</p>
<h2 id="SS和SP寄存器"><a href="#SS和SP寄存器" class="headerlink" title="SS和SP寄存器"></a>SS和SP寄存器</h2><p>这两个寄存器用来定义栈顶的位置，基于栈的操作都是基于这俩寄存器指定的位置来做操作。这俩也是段指令，无法直接<code>mov xx,数值</code>来直接赋值，得通过<code>mov 寄存器,段寄存器</code>来修改，或者通过debug名的r命令去修改。</p>
<h2 id="PUSH和POP指令"><a href="#PUSH和POP指令" class="headerlink" title="PUSH和POP指令"></a>PUSH和POP指令</h2><p>push就是压栈，指的是将一个元素添加到栈的顶部。pop就是出栈，指的是从栈的顶部移除并返回一个元素。<br>push和pop指令具体可以参考下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310112303.png"><br>下面做个实验，我们先指定1000:0010这块内存作为栈实验的栈顶，用来做压栈和出栈的实验，通过debug的r命令来修改ss和sp段寄存器，如下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310112811.png"><br>我们根据最上面的指令进行操作，我们先把指令写进去然后一步一步去执行，具体的汇编指令如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123</span><br><span class="line">push ax</span><br><span class="line">mov bx,2266</span><br><span class="line">push bx</span><br><span class="line">mov cx,1122</span><br><span class="line">push cx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br><span class="line">pop cx</span><br></pre></td></tr></table></figure>
<p>先去执行前两条查看一下栈里的内容有啥变化<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310113246.png"><br>0123被压入栈了，而且是顶部，并且SP也发生了更变，我们继续把压栈的命令都执行完，还剩4条，看一下结果<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310113424.png"><br>全部压进去了，并且位置是往小的来推进的。<br>接着我们继续执行指令，还有三条pop指令，先执行一条查看一下效果<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310113748.png"><br>原本栈内的2211，已经被丢到ax中了，并且他是把第一个丢到低位，然后第二个丢到高位中，这个操作不回去平衡高低位。接着继续执行两个pop命令，执行结果如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310114159.png"><br>栈内的数据以此丢到了bx和cx中了，并且栈内也没内容了，这里的内容其实我举得例子不好，应该找一块全空的位置来去做这个实验。这里他自动填充了其他数据。</p>
<h2 id="BX寄存器的独特性"><a href="#BX寄存器的独特性" class="headerlink" title="BX寄存器的独特性"></a>BX寄存器的独特性</h2><p>bx寄存器有一个额外的作用，就是它可以来指明内存单元，这个是其他大部分寄存器做不到的，举个例子，在2000:100的位置放一些数据，命令如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310141934.png"><br>修改DS数据段的地址为2000，然后通过偏移位置来去设置其他寄存器的内容，命令如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310142305.png"><br>这里发现ax成功更变成了2000:100位置的内容，这个在上面也进行过，下面开始通过bx来去当作编译来去拿数据，命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0102</span><br><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure>
<p><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310142447.png"><br>这里发现通过bx的偏移设置了ax的内容，他还有其他的写法，具体命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx-1]</span><br></pre></td></tr></table></figure>
<p><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310142632.png"><br>这样也是可以的，本身bx是<code>0102</code>通过<code>[bx-1]</code>那就是<code>0101</code>的偏移位置来写入ax，把寄存器当作偏移的操作只有bx能做到，尝试其他的会报错，具体错误可以参考下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310142844.png"><br>使用<code>mov cx,[ax]</code>和<code>mov ax,[cx]</code>都是不可行的，这个功能是bx单独的功能但不是他独有的功能，后面会说其他的，这个bx寄存器也一般用来存储偏移地址。</p>
<h2 id="SI和DI寄存器"><a href="#SI和DI寄存器" class="headerlink" title="SI和DI寄存器"></a>SI和DI寄存器</h2><p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。具体使用方法和上面BX寄存器一样。然后这些可以用来当作偏移来用的寄存器可以相加，例如下面汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,[bx+si]</span><br><span class="line">mov cx,[bx+di]</span><br><span class="line"># 下面这个不允许</span><br><span class="line">mov cx,[si+di]</span><br></pre></td></tr></table></figure>
<h2 id="BP寄存器"><a href="#BP寄存器" class="headerlink" title="BP寄存器"></a>BP寄存器</h2><p>他和上面的BX、SI、DI用处都是可以指明内存单元。但是BP在用法上和它们三个是有区别的，BX、SI、DI采用这三个寄存器去寻址的时候，他是基于DS寄存器来做偏移找内容，而BP是基于SS寄存器，这个SS寄存器上面也讲述了他是用来设置栈顶的段地址的，BP也可以理解为基于栈顶的位置偏移找内容。具体可以参考下面的案例，我在<code>5000:0000</code>和<code>6000:0000</code>的位置存放了一些内容，一个正序一个倒叙<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310154216.png"><br>下面我把这俩位置分给数据段地址和栈顶的位置，参考下面代码<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310154440.png"><br>之后开始测试数据，具体执行的汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0001</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov bp,0001</span><br><span class="line">mov ax,[bp]</span><br></pre></td></tr></table></figure>
<p><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310154637.png"><br>ax现在的内容是<code>5000:0000</code>位置偏移为1的内容，我们再去看bp的内容，继续执行两次查看结果<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310154752.png"><br>ax变成了A9CB，这里的内容是从<code>6000:0000</code>中拿出的。要注意的是bp是可以配合其他的寄存器和偏移使用的，但是他不可以配合bx寄存器来用，因为bx是基于DS寄存器的。具体参考下面汇编代码，以及报错输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+1]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line"># bp和bx不能一起用</span><br><span class="line">mov ax,[bp+bx]</span><br></pre></td></tr></table></figure>
<p>错误输出如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310155515.png"></p>
<h2 id="寻址寄存器相关总结"><a href="#寻址寄存器相关总结" class="headerlink" title="寻址寄存器相关总结"></a>寻址寄存器相关总结</h2><p><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310155832.png"></p>
<h2 id="标志位寄存器"><a href="#标志位寄存器" class="headerlink" title="标志位寄存器"></a>标志位寄存器</h2><p>CPU内部的寄存器中，有一种特殊的寄存器(低于不通的处理机，个数和结构都可能不同)具有以下三种作用。</p>
<ol>
<li>用来存储相关指令的某些执行结果。</li>
<li>用来为CPU执行相关指令提供行为依据。</li>
<li>用来控制CPU的相关工作方式。<br>这些特殊的寄存器在8086CPU中，被称为标志寄存器。8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)。我们已经使用过8086CPU的ax、bx、cx、dx、si、di、bp、sp、ip、cs、ss、ds、es等13个寄存器了，当前章节的标志寄存器(以下简称flag)是我们要学习的最后一个寄存器。<br>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。<br>8086CPU的flag寄存器的结构图如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310162649.png"><br>flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊的含义。<br>在这一章节中，我们学习标志寄存器中的CF、PF、ZF、SF、OF、DF标志位，以及一些与其相关的典型指令。</li>
</ol>
<h3 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h3><p>flag的第6位是ZF，0标志位。他记录相关指令执行后，其结果是否为0。如果结果为0，那么zf&#x3D;1；如果结果部位0，那么zf&#x3D;0。<br>参考下面汇编指令，来去验证zf的变动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure>
<p>执行结果在Debug中的体现如下图，先把ax改成1，执行之后NZ那个东西就是ZF标识即<code>NoZero</code>应该是这样理解，这是我自己理解的。然后等sub命令执行之后ax变成了0，ZF标志位变成了ZR，他代表<code>zero</code><br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310165002.png"></p>
<h3 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h3><p>flag的第二位是PF，奇偶标志位。他记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，pf&#x3D;1，如果奇数，那么pf&#x3D;0。在命令中的具体体现可以参考下面汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0000</span><br><span class="line">add ax,1</span><br><span class="line">add ax,1</span><br><span class="line">add ax,1</span><br></pre></td></tr></table></figure>
<p>执行结果如下，pe即代表偶数也就是pf&#x3D;1，po即代表是奇数也就是pf&#x3D;0<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250310170031.png"><br>然后这里有个问题，算奇数偶数为什么ax的值是1和2的时候都是奇数呢？因为他算的是一个bit中的1的数量，ax&#x3D;0001的时候，他的bit8位表示是<code>00000001</code>他就一个1所以标识奇数,ax&#x3D;0002的时候，他的bit8位标识是<code>00000010</code>，还是一个1，所以还是一个奇数。</p>
<h3 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h3><h4 id="负数如何表示？"><a href="#负数如何表示？" class="headerlink" title="负数如何表示？"></a>负数如何表示？</h4><p>在二进制中，负数的表示方式通常采用 补码，它的计算方法如下：</p>
<ul>
<li>正数：与原码相同</li>
<li>负数：<ol>
<li>先求该数的 绝对值的二进制（原码）。</li>
<li>按位取反（0 变 1，1 变 0）。</li>
<li>加 1（即 +1 操作）。</li>
</ol>
</li>
</ul>
<p>假设使用 8 位二进制来表示 -5：</p>
<ul>
<li>+5 的二进制（原码）: 00000101</li>
<li>按位取反: 11111010</li>
<li>加 1: 11111011（即 -5 的补码）</li>
</ul>
<p>所以，-5 在 8 位二进制中表示为：11111011</p>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>flag的第七位是SF，符号标志位。他记录相关指令后，结果是否为负。如果结果为负，SF&#x3D;1；如果非负，SF&#x3D;0。计算机中通常用补码来标识有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。比如：</p>
<ul>
<li>00000001B，可以看作为无符号数1，或有符号数+1;</li>
<li>10000001B，可以看作无符号数129，也可以看作有符号数-127；</li>
</ul>
<p>也就是说对于同一个二进制数据，计算机可以将他当作无符号数据来运算，也可以当作有符号数据来运算。比如下面汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B(81h)</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure>
<p>可以将add指令进行的运算当作无符号的运算，那么add指令相当于计算129+1，结果为130(10000010B)；也可以将add指令进行的运算当作有符号数的运算，那么add指令相当于计算-127+1，结果为-126(10000010B)。<br>下面举个例子，执行下面汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">add ax,1</span><br><span class="line">sub ax,1</span><br><span class="line">sub ax,1</span><br><span class="line">add ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure>
<p>执行4次后的输出如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313193258.png"><br>在mov的时候是ng即负，这应该是一个默认值，然后变成正数之后变成了PL，然后从0减到-1的时候变成了NG，好，继续运行<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313193535.png"><br>继续运行是+1然后-1 变成0之后在变-1,对应的这里的SF标志也在变。</p>
<h3 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h3><p>flag的第0位是CF，进位标志位。一般情况下，在进行无符号数运算的时候，他记录了运算结果的最高有效位向更高位的进位值，活从更高位的借位值。对于位数为N的无符号数来说，其对应的二进制信息的最高位。<br>看个例子，执行下面汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov al,10</span><br><span class="line">mov bl,10</span><br><span class="line">add al,bl</span><br><span class="line">mov al,20</span><br><span class="line">mov bl,21</span><br><span class="line">add al,bl</span><br><span class="line">mov al,98</span><br><span class="line">mov bl,98</span><br><span class="line">add al,bl</span><br></pre></td></tr></table></figure>
<p>先看前3个执行效果，如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313195107.png"><br>CY代表进位，NC代表没有，也可以理解为进位，是否影响了更高位<br>继续执行3个效果，运行结果如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313195227.png"><br>这里al-20去加bl-21变成了41，更高位没有变化，所以都是NC，继续执行后三条指令，运行结果如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313195351.png"><br>这里影响更高位了，98h+98h&#x3D;130h，所以变成了CY。</p>
<h3 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h3><p>在进行有符号运算的时候，如果结果超过了机器所能表示的范围称为溢出。<br>那么什么是机器所能表示的范围呢？<br>比如说，指令运算的结果用8位寄存器或内存单元来存放，比如，add al,3，那么对于8位的有符号数据，机器所能表示的范围就是-128<del>127。同理，对于16位有符号数据，机器所能表示的范围是-32768</del>32767。<br>注意，这里所说的溢出，只是对有符号数运算而言。参考下面的例子，汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,634</span><br><span class="line">mov al,63</span><br><span class="line">mov bl,62</span><br><span class="line">add al,bl</span><br><span class="line">mov al,10</span><br><span class="line">mov bl,20</span><br><span class="line">add al,bl</span><br><span class="line">mov al,ff</span><br><span class="line">mov bl,ff</span><br><span class="line">add al,bl</span><br><span class="line">mov al,aa</span><br><span class="line">mov bl,aa</span><br><span class="line">add al,bl</span><br></pre></td></tr></table></figure>
<p>先执行4次命令，结果如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313201854.png"><br>第一竖行是OF标志位，第二竖行是CF标志位，OV就是代表溢出了，那为什么63h+62h就溢出了？他会产生一个正的197，如果是带符号的那就是负的59，而8位能表示的范围是-128~127，不带符号的结果出现了溢出。继续运行3次指令，结果如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313203043.png"><br>这个是没有进位也没有溢出的结果，我们继续运行三次看一下结果<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313203249.png"><br>FF+FF最终是1FE，没有溢出但是影响了最高位，好，我们继续看，再次执行3次指令，结果如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313203428.png"><br>aa+aa的结果是154，高位进了，而且八位最高127，他这里154也溢出了。(这个位置其实我并没有理解，看了一会感觉应该是没那么重要，后面用到再回来看应该理解会更加深入一些，有清楚的大佬欢迎指正。)</p>
<h2 id="ADC指令"><a href="#ADC指令" class="headerlink" title="ADC指令"></a>ADC指令</h2><p>ADC是带进位加法指令，它利用了CF位上记录的进位值。具体用法参考下面汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br></pre></td></tr></table></figure>
<p>执行过后发现经过adc指令之后ax变成了4，ax(2)+1变成了4，为什么会这样呢？按照当前例子来算，他的加法原理是(ax)&#x3D;(ax)+(1)+CF，他在add基础上加上了一个CF标志位寄存器的内容，这个CF是一个进位的标志位，在第三条命令的时候bx(1)-ax(2)的时候借位了，而CF要么是0要么是1，借位的时候变成了1，他就会多加1，结果就变成4了。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313204425.png"><br>这个指令一般应用到下面场景，汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0198</span><br><span class="line">mov bx,0183</span><br><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br></pre></td></tr></table></figure>
<p>最终ax的结果是正确的，在al(98)+bl(83)的时候会产生进位，进位的那个一个数值会直接丢弃，通过adc计算高位就可以拿回刚才进位产生的一个数值。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250313205706.png"></p>
<h2 id="SBB指令"><a href="#SBB指令" class="headerlink" title="SBB指令"></a>SBB指令</h2><p>sbb是带借位减法指令，它利用了CF位上记录的借位值。举个例子，汇编指令为<code>sbb ax,bx</code>最终的运算结果是(ax) &#x3D; (ax) - (bx) - CF<br>这个指令和adc设计思想都是相同的，具体的例子这里不多讲述。虽然这两个命令并不常用，但是我们通过学习这两条指令，可以领会一下标志位寄存器CF位的作用和意义。</p>
<h2 id="CMP指令与跳转指令"><a href="#CMP指令与跳转指令" class="headerlink" title="CMP指令与跳转指令"></a>CMP指令与跳转指令</h2><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。CMP指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。具体参考如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ZF（零标志，Zero Flag）：如果比较结果为0（即目的操作数等于源操作数），ZF置1。</span><br><span class="line">SF（符号标志，Sign Flag）：结果的最高位（符号位）为1时，SF置1，表示结果为负。</span><br><span class="line">CF（进位标志，Carry Flag）：如果目的操作数小于源操作数（无符号数比较），CF置1。</span><br><span class="line">OF（溢出标志，Overflow Flag）：如果有符号数运算溢出，OF置1。</span><br><span class="line">PF（奇偶标志，Parity Flag）：结果低8位中1的个数为偶数时，PF置1。</span><br><span class="line">AF（辅助进位标志，Auxiliary Carry Flag）：低4位向高4位有进位时，AF置1。</span><br></pre></td></tr></table></figure>
<p>它通常与跳转指令配合使用，下面是一些常用的跳转指令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JE    等于则转移         ZF=1</span><br><span class="line">JNE   不等于则转移       ZF=0</span><br><span class="line">JB    低于则转移         CF=1</span><br><span class="line">JNB   不低于则转移       CF=0</span><br><span class="line">JA    高于则转移         CF=0且ZF=0</span><br><span class="line">JNA   不高于则转移       CF=1或CF=1</span><br></pre></td></tr></table></figure>
<p>这些指令都比较常用，它们都很好记忆，它们的第一个字母都是J，表示JUMP；后面的字母表示含义如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e  表示equal</span><br><span class="line">ne 表示not equal</span><br><span class="line">b  表示below</span><br><span class="line">nb 表示not below</span><br><span class="line">a  表示above</span><br><span class="line">nb 表示not above</span><br></pre></td></tr></table></figure>
<p>这里就不作实验了，后面会直接使用，具体可以参考下面章节的内容。</p>
<h1 id="源文件编写代码"><a href="#源文件编写代码" class="headerlink" title="源文件编写代码"></a>源文件编写代码</h1><h2 id="运行ASM源代码文件"><a href="#运行ASM源代码文件" class="headerlink" title="运行ASM源代码文件"></a>运行ASM源代码文件</h2><p>在最初安装学习环境的时候，工具包中提供了很多二进制命令，运行源码文件可以通过MASM去处理成OBJ文件，通过LINKE编译成可执行文件，然后通过debug去运行。具体参考案例如下<br>先创建一个asm文件，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    mov ax,0123H</span><br><span class="line">    mov bx,0456H</span><br><span class="line">    add ax,bx</span><br><span class="line">    add ax,ax</span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>之后在DOSBox中执行MASM指令去处理，参考下面运行结果<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314152530.png"><br>之后通过link去做编译<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314152551.png"><br>此时这个目录下会多出一个CODE.EXE，因为这些代码并没有实际能实现什么效果，直接运行不会出现任何内容，可以采用debug的形式去运行他，参考下面结果<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314152739.png"></p>
<h2 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h2><p>对于汇编指令，loop指令是无法在debug中写的，因为他是要去写函数的，在debug中无法直接去写，他涉及了一些伪指令，需要去txt中去写。LOOP指令的作用是循环，CPU在执行LOOP指令的时候，要进行两步操作，先是(cx)&#x3D;(cx)-1，然后判断cx中的值，不为零则转至标号处执行程序，如果为0则向下执行。具体参考例子为计算2的12次方，参考代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,11</span><br><span class="line">s: add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">    </span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>执行4次结果如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314163915.png"><br>loop干了一个偏移的事，把IP寄存器改成了0006，我们通过u命令查看一下这个位置的内容，如下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314164049.png"><br>发现0006就是s函数中的内容。继续执行会发现一直在0006这个偏移中跳转，并且发现CX每到loop的时候都会-1<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314164259.png"><br>一直到cx到0的时候IP到了000A，并且不再继续跳转，2的12次方也拿到了正确的数值<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314164429.png"><br>要注意的是，loop执行之前，cx不要为0，因为它运行会先去给cx-1，然后去判断是否为0再去执行，cx如果是0然后-1，那么他就会变成FFFF，会一直把FFFF循环完，近似于一个死循环了……</p>
<h2 id="Debug指令G"><a href="#Debug指令G" class="headerlink" title="Debug指令G"></a>Debug指令G</h2><p>上面的loop案例都是通过debug的t指令一步一步执行的，我们也可以使用debug的g指令一次性执行到头，例如我们整个命令是到<code>000A</code>结束，参考下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314164821.png"><br>我们可以直接通过debug的g命令运行到这个位置，使用结果如下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314165006.png"><br>直接用G跳转到了<code>000A</code>并且成功运算出了结果。</p>
<h2 id="Debug指令P"><a href="#Debug指令P" class="headerlink" title="Debug指令P"></a>Debug指令P</h2><p>上面使用了t一步一步执行，也用了g一次性执行到某个位置，然后我再学习一下p指令，他的作用是把当前当前循环执行的命令一次性运行完。参考下面执行结果<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314165421.png"><br>CX到A也就是10的时候我这里直接输入p一次性执行完循环了，直接成功运算出了结果。</p>
<h2 id="CALL与RET指令"><a href="#CALL与RET指令" class="headerlink" title="CALL与RET指令"></a>CALL与RET指令</h2><p>call和ret都是转移指令，他们都修改IP，或同时修改CS和IP。他们经常被共同用来实现子程序的设计。上面是简单创建了一个函数去使用，函数写进去之后，会被直接根据顺序直接调用，那么我们如何更优雅的去运行他们呢？这里就可以通过CALL和RET指令来去配合使用，具体参考下面代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,11</span><br><span class="line">    call s</span><br><span class="line">    int 21H</span><br><span class="line">s: add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">    ret</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>运行就不具体运行了，要注意的是<code>int 21H</code>这个中断，这个中断的含义是用来结束运行的，如果没有这个则会继续返回到call执行的下一个指令即运行s函数的内容，可能会造成于一个近似死循环的一个行为。。。</p>
<h3 id="RET和RETF"><a href="#RET和RETF" class="headerlink" title="RET和RETF"></a>RET和RETF</h3><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；<br>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。<br>具体应用的体现在哪呢？如果使用ret，他只能修改IP的内容，也就是偏移的值，但是偏移是有上线的，在8086CPU中，偏移的上线是<code>FFFF</code>，超过这个就回不去了，而retf还可以修改cs寄存器，这样修能实现远偏移。</p>
<h3 id="call和“call-far-ptr”"><a href="#call和“call-far-ptr”" class="headerlink" title="call和“call far ptr”"></a>call和“call far ptr”</h3><p>call和“call far ptr”的关系和ret与reft的关系基本对应，有一个近远的区别。<br>具体使用就是下面代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,3</span><br><span class="line">    mov cx,11</span><br><span class="line">    call far ptr s</span><br><span class="line">    int 21H</span><br><span class="line">s: add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">    retf</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>我这里就不继续运行了，看一参考底部案例实践的内容。</p>
<h3 id="CALL指令的本质"><a href="#CALL指令的本质" class="headerlink" title="CALL指令的本质"></a>CALL指令的本质</h3><p>CPU执行CALL指令的时候，会进行两步操作，首先会把当前的IP或CS和IP压入栈中。然后转移到被调函数的位置。CALL指令不能实现短转移，除此之外，CALL指令实现转移的方法和JMP指令的原理相同。</p>
<h3 id="RET指令的本质"><a href="#RET指令的本质" class="headerlink" title="RET指令的本质"></a>RET指令的本质</h3><p>当CALL指令把指针相关数据压入栈中，最终执行到RET的时候，会进行弹栈的操作，然后修改指针偏移。</p>
<h3 id="案例实践"><a href="#案例实践" class="headerlink" title="案例实践"></a>案例实践</h3><p>以下面代码为例,我们看一下栈中的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,11</span><br><span class="line">    call s</span><br><span class="line">    int 21H</span><br><span class="line">s: add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">    ret</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>我们先设置一块空的地方为栈顶<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314205856.png"><br>然后把命令执行到call s的下一条指令，看一下栈中的数据<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314210009.png"><br>这里存储了一个0900，这个是高低位转换之后的，实际应该是<code>0009</code>，我们再看一下我们命令的偏移，如下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314210157.png"><br>0009的偏移位置是直接<code>ini 21</code>刚好对应执行顺序，我们去运行到ret的时候会自动弹栈拿到这个位置，并跳转。一直到ret，CS和IP的内容更变如下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314210314.png"><br>这里是<code>call</code>和<code>ret</code>的对应关系，然后<code>call far ptr</code>和<code>reft</code>是对应的，远位转移在栈中存储的是CS和IP的位置，这个要注意，具体参考下图。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250314204059.png"></p>
<h2 id="代码中装载数据"><a href="#代码中装载数据" class="headerlink" title="代码中装载数据"></a>代码中装载数据</h2><p>MASM内部以数据位的个数定义了多种数据类型</p>
<ul>
<li>BYTE，db，8bit</li>
<li>WORD，dw，16bit</li>
<li>DWORD，dd，32bit</li>
<li>QWORD，dq，64bit</li>
</ul>
<p>我们通过debug用这些指令定义数据查看一下会CPU会执行什么内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dw 1234</span><br><span class="line">dw 456,789</span><br><span class="line">dw abcd,ef,123,456,789</span><br></pre></td></tr></table></figure>
<p><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315132312.png"><br>他把这些数据直接丢到了代码段，在汇编中，数据和指令是不会去做区分的，数据可以当作指令去执行，指令也可以当作数据去用。再去参考下面汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    dw 0123h, 4567h, 89ABh</span><br><span class="line">    mov ax, 0</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>把上面代码丢到debug中运行，再去查看代码段的内容会发现，前面数据都是对的，后面的mov指令变没了，出现这个问题主要是因为上面说的，数据和指令他不会去做区分，拿到什么内容既可以当作数据也可以当作命令，这里的数据堆起来之后变成了另外的命令，所以mov指令就没了<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315134654.png"><br>想要做到分离数据与指令，可以通过下面的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    dw 0123h, 4567h, 89ABh</span><br><span class="line">start: mov ax, 0</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>主要是在数据定义完之后通过<code>start</code>创建一个指令入口，我们放到debug中查看一下与上面的区别<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315135359.png"><br>使用start的代码最终执行的时候IP会自动到指令的位置，而不是从头执行，虽然这里通过debug的u指令看到命令还是乱的，但是IP寄存器指向的位置却是一个正常的。</p>
<h2 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">    db &#x27;Hello, world!&#x27;</span><br><span class="line">    dw 123h, 456h, 789h, 0ABh,0defh</span><br><span class="line">    db 3 dup (1,2,3)</span><br><span class="line">    db 3 dup (&#x27;abc&#x27;,&#x27;def&#x27;)</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">    db 10 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">    start: mov ax, 0</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>参考上面汇编代码，其中cs、ds、ss分别用来定义不通的段，这三个具体的含义参考如下</p>
<ul>
<li>cs:code: 将代码段寄存器（CS）关联到名为 code 的段，表示程序的指令存放在 code 段。</li>
<li>ds:data: 将数据段寄存器（DS）关联到名为 data 的段，表示程序的数据存放在 data 段。</li>
<li>ss:stack: 将堆栈段寄存器（SS）关联到名为 stack 的段，表示程序的堆栈存放在 stack 段。</li>
</ul>
<p>然后这里还引入了一个dup指令，他的含义是数据需要多少份来放到对应的位置。例如上面的<code>db 10 dup (0)</code> 意为创建10份为0的数据。再data段的dw指令，后面的数据为什么都带<code>0</code>，原因是因为MASM是不支持16进制以字母开头的，全字母需要使用<code>0</code>来作为前缀<br>然后这里再具体说一下start的含义，他是用来定义代码运行的起始位置的，然后后面的<code>end start</code>是执行完成之后还会回到start的最初位置。我们运行一下代码，查看这些数据是什么形式存储的<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315150452.png"><br>首先开启程序之后CS和IP寄存器和原本的不一样，原因是因为之前的位置都存储了数据，通过d指令去查看原本位置的内容，我们的代码存储了字母，字母的存储方式为字母的ascii码的16进制，丢到里面，然后以知道bcdef，也就是076A:0030的位置，填充完后面还是跟随了很多0，然后紧接着是栈段的10个0，但是他这里存储的不仅仅是10个，除去ef，就是14+16个0，为什么会这样？因为每一个段不是通过偏移来设置位置的，而是通过CS，CS是必须被16整除的，也就是说如果细分到16以内的位置只能通过偏移来找，就是说基础单位就是16个，最终的数据如果是没撑满这16位，那么剩下的他都会不作为，并且依旧作为当前段的内容，包括上面定义的stack。所以实际数据段和栈段的范围是这样的<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315151141.png"><br>上面的红框是数据段，下面的红框是栈段。</p>
<h2 id="OFFSET指令"><a href="#OFFSET指令" class="headerlink" title="OFFSET指令"></a>OFFSET指令</h2><p>offset是只能在编写代码文件时使用的指令，他的作用是获取某个数据的位置，具体可以参考下面汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    a: db 10 dup(10H)</span><br><span class="line">    b: db 10 dup(11H)</span><br><span class="line">    ; start: mov ax,offset a[0]</span><br><span class="line">    ; mov bx,offset b[0]</span><br><span class="line">    start: mov ax,offset a</span><br><span class="line">           mov bx,offset b</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>直接查看内存中的内容，然后再去看要执行的内容，结果如下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315191910.png"><br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315191929.png"><br>写入了10个<code>10</code>和<code>11</code>，在执行MOV的时候对应的值也是这俩数据的偏移位置，这就是offset的作用，用来查找对应数据的偏移值。</p>
<h2 id="JMP指令进阶"><a href="#JMP指令进阶" class="headerlink" title="JMP指令进阶"></a>JMP指令进阶</h2><p>jmp的作用是跳转，上面也实践了一下，他还有很多其他写法，这里列举一下</p>
<ul>
<li><code>jmp short</code> 近跳转，通过修改IP来跳转偏移，偏移量是一个有符号的 8 位数，范围为 -128 到 +127 字节。</li>
<li><code>jump far ptr</code> 远跳转，通过CS和IP来跳转，它可以实现很远的跳转。</li>
<li><code>jmp near ptr</code> 这个跳转是拿到数值的2个字节来跳转</li>
<li><code>jmp dword ptr</code> 这个跳转是拿到数值的4个字节来跳转</li>
</ul>
<p>具体举个他们的例子，汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    start: jmp short a</span><br><span class="line">    ; 如果这里不注释这256个db则是跳转不过去的,大家可以自己尝试</span><br><span class="line">    ; 跳转不过去的原因是因为近跳转范围只有`-128`~`127`字节</span><br><span class="line">    ; db 256 dup(0)</span><br><span class="line">    a: </span><br><span class="line">        mov ax,1H</span><br><span class="line">        jmp far ptr b</span><br><span class="line">        db 256 dup(0)</span><br><span class="line">    b: </span><br><span class="line">        mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov ax,offset c</span><br><span class="line">        mov ds:[0],ax</span><br><span class="line">        jmp word ptr ds:[0]</span><br><span class="line">    c:</span><br><span class="line">        mov ax,offset d</span><br><span class="line">        ; mov ds:[0],0000h</span><br><span class="line">        mov ds:[0],ax</span><br><span class="line">        mov ds:[2],cs</span><br><span class="line">        jmp dword ptr ds:[0]</span><br><span class="line">    d: </span><br><span class="line">        mov ax,0FFFFh</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>先看前3条执行过程，如下图，第一个jmp是采用一个偏移的方式，第二个jmp是采用一个地址段+偏移的方式<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201358.png"><br>我们继续运行，查看第三个jmp，如下图，第三个jmp直接跳转DS的0000位置的地址<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201416.png"><br>我们再去看一下这个DS:0000的内容，这个内容是什么那么他就会跳转到哪里，不出意外应该是在上图的倒数第三个位置，应该是0118，也就是C的偏移位置<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201445.png"><br>因为有高低位平衡，所以这里是1801，实际就是0118，那这个偏移位置的内容是什么呢？我们继续用u指令看一下<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201507.png"><br>很明显这里就是C函数的入口，并且D函数的入口也被C的第一条指令打进了DS:0000的位置，然后采用JMP去跳转，我们先看一下jmp之前的DS:0000的内容，是不是076A:0126，我们继续运行<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201639.png"><br>发现是没问题的，因为存在高低位平衡，所以是26016A07实际就是076A0126，分别指向下一个CS和IP的正确位置，我们继续运行<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315201758.png"><br>程序成功退出结束。</p>
<h2 id="JCXZ指令"><a href="#JCXZ指令" class="headerlink" title="JCXZ指令"></a>JCXZ指令</h2><p>JCXZ是一条条件跳转指令，它的功能是检查CX寄存器是否为零，如果CX寄存器等于零，则跳转到指定的目标地址；如果CX寄存器不等于零，则继续执行下一条指令。具体参考代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax, 2       ; AX初始值为2</span><br><span class="line">    mov cx, 11      ; CX设为11，表示循环11次</span><br><span class="line">a:  </span><br><span class="line">    jcxz done       ; 如果CX为0，跳到done</span><br><span class="line">    add ax, ax      ; AX = AX + AX（AX乘以2）</span><br><span class="line">    dec cx          ; CX减1</span><br><span class="line">    jmp a           ; 无条件跳回a，继续循环</span><br><span class="line">done:               ; 循环结束</span><br><span class="line">    mov ah, 4Ch     ; 设置AH=4Ch，退出程序</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>循环结束之后直接跳出了，这里需要一次性执行好多次t，可以自己修改代码，尝试个一两次知道怎么用就可以了。<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315203531.png"></p>
<h2 id="TYPE伪指令"><a href="#TYPE伪指令" class="headerlink" title="TYPE伪指令"></a>TYPE伪指令</h2><p>TYPE 可以用来查询某个变量的类型，返回其占用的字节数。简单举个例子，参考下面汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line">data segment</span><br><span class="line">    var1 DB 10h         ; 定义一个字节变量</span><br><span class="line">    var2 DW 1234h       ; 定义一个字变量</span><br><span class="line">    var3 DD 0DEADBEEFh  ; 定义一个双字变量</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax, TYPE var1   ; AX = 1（var1 是字节）</span><br><span class="line">    mov bx, TYPE var2   ; BX = 2（var2 是字）</span><br><span class="line">    mov cx, TYPE var3   ; CX = 4（var3 是双字）</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h2 id="数组的读取和写入"><a href="#数组的读取和写入" class="headerlink" title="数组的读取和写入"></a>数组的读取和写入</h2><p>在代码段中读取和写入数组，直接上汇编代码，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">    db 10 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">    arr db 12,34,56,78,9AH</span><br><span class="line">    start: </span><br><span class="line">           mov al,arr[2]</span><br><span class="line">           mov al,arr[4]</span><br><span class="line">           mov ax,word ptr arr[2]</span><br><span class="line">           mov si,offset arr</span><br><span class="line">           mov al,cs:[si+4] </span><br><span class="line">           mov al,cs:[si+6]</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>我们看一下每个mov执行实际给的内容，如下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315211019.png"><br>上面是执行了4次，我们挨个看内容，第一个把al设置成了数组中的第二个数据也就是56，56的16进制刚好为38，然后他继续去拿第四个位置的内容是9A，咱们定义的时候也是直接的16进制的9A，所以这里也是没问题的，然后有执行了一个ax为第二个内容，但是这里为什么是4e38呢？<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315211949.png"><br>其实这里也是对的，通过d命令去查看这个位置的确就是这个内容。我们继续运行，查看内容<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315212153.png"><br>si拿到的数据是arr的0位偏移，也就是0000，这里拿到的内容也都是预期的。<br>上面的例子是基于代码段来去操作数据，下面来一个不同段的，原理都一样，主要是这里多了一个修改DS地址的指令，主要参考与下面汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">    arr db 10H,20H,30H,40H,50H</span><br><span class="line">    arr2 db &#x27;hello world&#x27;</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">    db 10 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">    start: </span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        </span><br><span class="line">        mov al,arr[2]</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>我们执行以下看一下al的数据，如下图<br><img src="https://image.boychai.xyz/article/sync/Pasted%20image%2020250315213751.png"><br>还有一些额外写法都可以参考上面代码段中使用数组的汇编代码，这里DS修改之后就全都对的上了。然后如果数组不加<code>[]</code>那么他就是直接引用0的偏移位置。</p>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>上面均为自己学习整理的笔记，仅限参考，也欢迎大佬指出错误，非常感谢。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/asm/" rel="tag"># asm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/02/15/OpenStack-%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" rel="prev" title="OpenStack-内部网络原理分析">
                  <i class="fa fa-angle-left"></i> OpenStack-内部网络原理分析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/03/18/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E5%8E%BB%E9%99%A4%E5%B9%BF%E5%91%8A/" rel="next" title="记一次安卓逆向学习实践-去除广告">
                  记一次安卓逆向学习实践-去除广告 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">BoyChai</span>
    <a href="/atom.xml" target="_blank">RSS</a>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">158k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:36</span>
  </span>
</div>
<div class="busuanzi-count">
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动 
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-server-ten-phi.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":false,"pageview":false,"avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"requiredMeta":["nick","mail"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2025/03/10/8086CPU%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
